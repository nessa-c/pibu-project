"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-router";
exports.ids = ["vendor-chunks/react-router"];
exports.modules = {

/***/ "(ssr)/../../../node_modules/react-router/dist/index.js":
/*!********************************************************!*\
  !*** ../../../node_modules/react-router/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortedDeferredError: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.AbortedDeferredError),\n/* harmony export */   Await: () => (/* binding */ Await),\n/* harmony export */   MemoryRouter: () => (/* binding */ MemoryRouter),\n/* harmony export */   Navigate: () => (/* binding */ Navigate),\n/* harmony export */   NavigationType: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.Action),\n/* harmony export */   Outlet: () => (/* binding */ Outlet),\n/* harmony export */   Route: () => (/* binding */ Route),\n/* harmony export */   Router: () => (/* binding */ Router),\n/* harmony export */   RouterProvider: () => (/* binding */ RouterProvider),\n/* harmony export */   Routes: () => (/* binding */ Routes),\n/* harmony export */   UNSAFE_DataRouterContext: () => (/* binding */ DataRouterContext),\n/* harmony export */   UNSAFE_DataRouterStateContext: () => (/* binding */ DataRouterStateContext),\n/* harmony export */   UNSAFE_LocationContext: () => (/* binding */ LocationContext),\n/* harmony export */   UNSAFE_NavigationContext: () => (/* binding */ NavigationContext),\n/* harmony export */   UNSAFE_RouteContext: () => (/* binding */ RouteContext),\n/* harmony export */   UNSAFE_mapRouteProperties: () => (/* binding */ mapRouteProperties),\n/* harmony export */   UNSAFE_useRouteId: () => (/* binding */ useRouteId),\n/* harmony export */   UNSAFE_useRoutesImpl: () => (/* binding */ useRoutesImpl),\n/* harmony export */   createMemoryRouter: () => (/* binding */ createMemoryRouter),\n/* harmony export */   createPath: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.createPath),\n/* harmony export */   createRoutesFromChildren: () => (/* binding */ createRoutesFromChildren),\n/* harmony export */   createRoutesFromElements: () => (/* binding */ createRoutesFromChildren),\n/* harmony export */   defer: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.defer),\n/* harmony export */   generatePath: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.generatePath),\n/* harmony export */   isRouteErrorResponse: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.isRouteErrorResponse),\n/* harmony export */   json: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.json),\n/* harmony export */   matchPath: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.matchPath),\n/* harmony export */   matchRoutes: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.matchRoutes),\n/* harmony export */   parsePath: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.parsePath),\n/* harmony export */   redirect: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.redirect),\n/* harmony export */   redirectDocument: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.redirectDocument),\n/* harmony export */   renderMatches: () => (/* binding */ renderMatches),\n/* harmony export */   resolvePath: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.resolvePath),\n/* harmony export */   useActionData: () => (/* binding */ useActionData),\n/* harmony export */   useAsyncError: () => (/* binding */ useAsyncError),\n/* harmony export */   useAsyncValue: () => (/* binding */ useAsyncValue),\n/* harmony export */   useBlocker: () => (/* binding */ useBlocker),\n/* harmony export */   useHref: () => (/* binding */ useHref),\n/* harmony export */   useInRouterContext: () => (/* binding */ useInRouterContext),\n/* harmony export */   useLoaderData: () => (/* binding */ useLoaderData),\n/* harmony export */   useLocation: () => (/* binding */ useLocation),\n/* harmony export */   useMatch: () => (/* binding */ useMatch),\n/* harmony export */   useMatches: () => (/* binding */ useMatches),\n/* harmony export */   useNavigate: () => (/* binding */ useNavigate),\n/* harmony export */   useNavigation: () => (/* binding */ useNavigation),\n/* harmony export */   useNavigationType: () => (/* binding */ useNavigationType),\n/* harmony export */   useOutlet: () => (/* binding */ useOutlet),\n/* harmony export */   useOutletContext: () => (/* binding */ useOutletContext),\n/* harmony export */   useParams: () => (/* binding */ useParams),\n/* harmony export */   useResolvedPath: () => (/* binding */ useResolvedPath),\n/* harmony export */   useRevalidator: () => (/* binding */ useRevalidator),\n/* harmony export */   useRouteError: () => (/* binding */ useRouteError),\n/* harmony export */   useRouteLoaderData: () => (/* binding */ useRouteLoaderData),\n/* harmony export */   useRoutes: () => (/* binding */ useRoutes)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _remix_run_router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @remix-run/router */ \"(ssr)/../../../node_modules/@remix-run/router/dist/router.js\");\n/**\n * React Router v6.21.3\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */ \n\n\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\n// Create react-specific types from the agnostic types in @remix-run/router to\n// export from react-router\nconst DataRouterContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nif (true) {\n    DataRouterContext.displayName = \"DataRouter\";\n}\nconst DataRouterStateContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nif (true) {\n    DataRouterStateContext.displayName = \"DataRouterState\";\n}\nconst AwaitContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nif (true) {\n    AwaitContext.displayName = \"Await\";\n}\n/**\n * A Navigator is a \"location changer\"; it's how you get to different locations.\n *\n * Every history instance conforms to the Navigator interface, but the\n * distinction is useful primarily when it comes to the low-level `<Router>` API\n * where both the location and a navigator must be provided separately in order\n * to avoid \"tearing\" that may occur in a suspense-enabled app if the action\n * and/or location were to be read directly from the history instance.\n */ const NavigationContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nif (true) {\n    NavigationContext.displayName = \"Navigation\";\n}\nconst LocationContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nif (true) {\n    LocationContext.displayName = \"Location\";\n}\nconst RouteContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n    outlet: null,\n    matches: [],\n    isDataRoute: false\n});\nif (true) {\n    RouteContext.displayName = \"Route\";\n}\nconst RouteErrorContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nif (true) {\n    RouteErrorContext.displayName = \"RouteError\";\n}\n/**\n * Returns the full href for the given \"to\" value. This is useful for building\n * custom links that are also accessible and preserve right-click behavior.\n *\n * @see https://reactrouter.com/hooks/use-href\n */ function useHref(to, _temp) {\n    let { relative } = _temp === void 0 ? {} : _temp;\n    !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, // router loaded. We can help them understand how to avoid that.\n    \"useHref() may be used only in the context of a <Router> component.\") : 0 : void 0;\n    let { basename, navigator } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);\n    let { hash, pathname, search } = useResolvedPath(to, {\n        relative\n    });\n    let joinedPathname = pathname;\n    // If we're operating within a basename, prepend it to the pathname prior\n    // to creating the href.  If this is a root navigation, then just use the raw\n    // basename which allows the basename to have full control over the presence\n    // of a trailing slash on root links\n    if (basename !== \"/\") {\n        joinedPathname = pathname === \"/\" ? basename : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.joinPaths)([\n            basename,\n            pathname\n        ]);\n    }\n    return navigator.createHref({\n        pathname: joinedPathname,\n        search,\n        hash\n    });\n}\n/**\n * Returns true if this component is a descendant of a `<Router>`.\n *\n * @see https://reactrouter.com/hooks/use-in-router-context\n */ function useInRouterContext() {\n    return react__WEBPACK_IMPORTED_MODULE_0__.useContext(LocationContext) != null;\n}\n/**\n * Returns the current location object, which represents the current URL in web\n * browsers.\n *\n * Note: If you're using this it may mean you're doing some of your own\n * \"routing\" in your app, and we'd like to know what your use case is. We may\n * be able to provide something higher-level to better suit your needs.\n *\n * @see https://reactrouter.com/hooks/use-location\n */ function useLocation() {\n    !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, // router loaded. We can help them understand how to avoid that.\n    \"useLocation() may be used only in the context of a <Router> component.\") : 0 : void 0;\n    return react__WEBPACK_IMPORTED_MODULE_0__.useContext(LocationContext).location;\n}\n/**\n * Returns the current navigation action which describes how the router came to\n * the current location, either by a pop, push, or replace on the history stack.\n *\n * @see https://reactrouter.com/hooks/use-navigation-type\n */ function useNavigationType() {\n    return react__WEBPACK_IMPORTED_MODULE_0__.useContext(LocationContext).navigationType;\n}\n/**\n * Returns a PathMatch object if the given pattern matches the current URL.\n * This is useful for components that need to know \"active\" state, e.g.\n * `<NavLink>`.\n *\n * @see https://reactrouter.com/hooks/use-match\n */ function useMatch(pattern) {\n    !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, // router loaded. We can help them understand how to avoid that.\n    \"useMatch() may be used only in the context of a <Router> component.\") : 0 : void 0;\n    let { pathname } = useLocation();\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>(0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.matchPath)(pattern, pathname), [\n        pathname,\n        pattern\n    ]);\n}\n/**\n * The interface for the navigate() function returned from useNavigate().\n */ const navigateEffectWarning = \"You should call navigate() in a React.useEffect(), not when \" + \"your component is first rendered.\";\n// Mute warnings for calls to useNavigate in SSR environments\nfunction useIsomorphicLayoutEffect(cb) {\n    let isStatic = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext).static;\n    if (!isStatic) {\n        // We should be able to get rid of this once react 18.3 is released\n        // See: https://github.com/facebook/react/pull/26395\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(cb);\n    }\n}\n/**\n * Returns an imperative method for changing the location. Used by `<Link>`s, but\n * may also be used by other elements to change the location.\n *\n * @see https://reactrouter.com/hooks/use-navigate\n */ function useNavigate() {\n    let { isDataRoute } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n    // Conditional usage is OK here because the usage of a data router is static\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    return isDataRoute ? useNavigateStable() : useNavigateUnstable();\n}\nfunction useNavigateUnstable() {\n    !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, // router loaded. We can help them understand how to avoid that.\n    \"useNavigate() may be used only in the context of a <Router> component.\") : 0 : void 0;\n    let dataRouterContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterContext);\n    let { basename, future, navigator } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);\n    let { matches } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n    let { pathname: locationPathname } = useLocation();\n    let routePathnamesJson = JSON.stringify((0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_getResolveToMatches)(matches, future.v7_relativeSplatPath));\n    let activeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    useIsomorphicLayoutEffect(()=>{\n        activeRef.current = true;\n    });\n    let navigate = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function(to, options) {\n        if (options === void 0) {\n            options = {};\n        }\n         true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(activeRef.current, navigateEffectWarning) : 0;\n        // Short circuit here since if this happens on first render the navigate\n        // is useless because we haven't wired up our history listener yet\n        if (!activeRef.current) return;\n        if (typeof to === \"number\") {\n            navigator.go(to);\n            return;\n        }\n        let path = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.resolveTo)(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === \"path\");\n        // If we're operating within a basename, prepend it to the pathname prior\n        // to handing off to history (but only if we're not in a data router,\n        // otherwise it'll prepend the basename inside of the router).\n        // If this is a root navigation, then we navigate to the raw basename\n        // which allows the basename to have full control over the presence of a\n        // trailing slash on root links\n        if (dataRouterContext == null && basename !== \"/\") {\n            path.pathname = path.pathname === \"/\" ? basename : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.joinPaths)([\n                basename,\n                path.pathname\n            ]);\n        }\n        (!!options.replace ? navigator.replace : navigator.push)(path, options.state, options);\n    }, [\n        basename,\n        navigator,\n        routePathnamesJson,\n        locationPathname,\n        dataRouterContext\n    ]);\n    return navigate;\n}\nconst OutletContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n/**\n * Returns the context (if provided) for the child route at this level of the route\n * hierarchy.\n * @see https://reactrouter.com/hooks/use-outlet-context\n */ function useOutletContext() {\n    return react__WEBPACK_IMPORTED_MODULE_0__.useContext(OutletContext);\n}\n/**\n * Returns the element for the child route at this level of the route\n * hierarchy. Used internally by `<Outlet>` to render child routes.\n *\n * @see https://reactrouter.com/hooks/use-outlet\n */ function useOutlet(context) {\n    let outlet = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext).outlet;\n    if (outlet) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(OutletContext.Provider, {\n            value: context\n        }, outlet);\n    }\n    return outlet;\n}\n/**\n * Returns an object of key/value pairs of the dynamic params from the current\n * URL that were matched by the route path.\n *\n * @see https://reactrouter.com/hooks/use-params\n */ function useParams() {\n    let { matches } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n    let routeMatch = matches[matches.length - 1];\n    return routeMatch ? routeMatch.params : {};\n}\n/**\n * Resolves the pathname of the given `to` value against the current location.\n *\n * @see https://reactrouter.com/hooks/use-resolved-path\n */ function useResolvedPath(to, _temp2) {\n    let { relative } = _temp2 === void 0 ? {} : _temp2;\n    let { future } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);\n    let { matches } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n    let { pathname: locationPathname } = useLocation();\n    let routePathnamesJson = JSON.stringify((0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_getResolveToMatches)(matches, future.v7_relativeSplatPath));\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>(0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.resolveTo)(to, JSON.parse(routePathnamesJson), locationPathname, relative === \"path\"), [\n        to,\n        routePathnamesJson,\n        locationPathname,\n        relative\n    ]);\n}\n/**\n * Returns the element of the route that matched the current location, prepared\n * with the correct context to render the remainder of the route tree. Route\n * elements in the tree must render an `<Outlet>` to render their child route's\n * element.\n *\n * @see https://reactrouter.com/hooks/use-routes\n */ function useRoutes(routes, locationArg) {\n    return useRoutesImpl(routes, locationArg);\n}\n// Internal implementation with accept optional param for RouterProvider usage\nfunction useRoutesImpl(routes, locationArg, dataRouterState, future) {\n    !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, // router loaded. We can help them understand how to avoid that.\n    \"useRoutes() may be used only in the context of a <Router> component.\") : 0 : void 0;\n    let { navigator } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);\n    let { matches: parentMatches } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n    let routeMatch = parentMatches[parentMatches.length - 1];\n    let parentParams = routeMatch ? routeMatch.params : {};\n    let parentPathname = routeMatch ? routeMatch.pathname : \"/\";\n    let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : \"/\";\n    let parentRoute = routeMatch && routeMatch.route;\n    if (true) {\n        // You won't get a warning about 2 different <Routes> under a <Route>\n        // without a trailing *, but this is a best-effort warning anyway since we\n        // cannot even give the warning unless they land at the parent route.\n        //\n        // Example:\n        //\n        // <Routes>\n        //   {/* This route path MUST end with /* because otherwise\n        //       it will never match /blog/post/123 */}\n        //   <Route path=\"blog\" element={<Blog />} />\n        //   <Route path=\"blog/feed\" element={<BlogFeed />} />\n        // </Routes>\n        //\n        // function Blog() {\n        //   return (\n        //     <Routes>\n        //       <Route path=\"post/:id\" element={<Post />} />\n        //     </Routes>\n        //   );\n        // }\n        let parentPath = parentRoute && parentRoute.path || \"\";\n        warningOnce(parentPathname, !parentRoute || parentPath.endsWith(\"*\"), \"You rendered descendant <Routes> (or called `useRoutes()`) at \" + ('\"' + parentPathname + '\" (under <Route path=\"' + parentPath + '\">) but the ') + 'parent route path has no trailing \"*\". This means if you navigate ' + \"deeper, the parent won't match anymore and therefore the child \" + \"routes will never render.\\n\\n\" + ('Please change the parent <Route path=\"' + parentPath + '\"> to <Route ') + ('path=\"' + (parentPath === \"/\" ? \"*\" : parentPath + \"/*\") + '\">.'));\n    }\n    let locationFromContext = useLocation();\n    let location;\n    if (locationArg) {\n        var _parsedLocationArg$pa;\n        let parsedLocationArg = typeof locationArg === \"string\" ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.parsePath)(locationArg) : locationArg;\n        !(parentPathnameBase === \"/\" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, \" + \"the location pathname must begin with the portion of the URL pathname that was \" + ('matched by all parent routes. The current pathname base is \"' + parentPathnameBase + '\" ') + ('but pathname \"' + parsedLocationArg.pathname + '\" was given in the `location` prop.')) : 0 : void 0;\n        location = parsedLocationArg;\n    } else {\n        location = locationFromContext;\n    }\n    let pathname = location.pathname || \"/\";\n    let remainingPathname = parentPathnameBase === \"/\" ? pathname : pathname.slice(parentPathnameBase.length) || \"/\";\n    let matches = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.matchRoutes)(routes, {\n        pathname: remainingPathname\n    });\n    if (true) {\n         true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(parentRoute || matches != null, 'No routes matched location \"' + location.pathname + location.search + location.hash + '\" ') : 0;\n         true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(matches == null || matches[matches.length - 1].route.element !== undefined || matches[matches.length - 1].route.Component !== undefined || matches[matches.length - 1].route.lazy !== undefined, 'Matched leaf route at location \"' + location.pathname + location.search + location.hash + '\" ' + \"does not have an element or Component. This means it will render an <Outlet /> with a \" + 'null value by default resulting in an \"empty\" page.') : 0;\n    }\n    let renderedMatches = _renderMatches(matches && matches.map((match)=>Object.assign({}, match, {\n            params: Object.assign({}, parentParams, match.params),\n            pathname: (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.joinPaths)([\n                parentPathnameBase,\n                // Re-encode pathnames that were decoded inside matchRoutes\n                navigator.encodeLocation ? navigator.encodeLocation(match.pathname).pathname : match.pathname\n            ]),\n            pathnameBase: match.pathnameBase === \"/\" ? parentPathnameBase : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.joinPaths)([\n                parentPathnameBase,\n                // Re-encode pathnames that were decoded inside matchRoutes\n                navigator.encodeLocation ? navigator.encodeLocation(match.pathnameBase).pathname : match.pathnameBase\n            ])\n        })), parentMatches, dataRouterState, future);\n    // When a user passes in a `locationArg`, the associated routes need to\n    // be wrapped in a new `LocationContext.Provider` in order for `useLocation`\n    // to use the scoped location instead of the global location.\n    if (locationArg && renderedMatches) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(LocationContext.Provider, {\n            value: {\n                location: _extends({\n                    pathname: \"/\",\n                    search: \"\",\n                    hash: \"\",\n                    state: null,\n                    key: \"default\"\n                }, location),\n                navigationType: _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.Action.Pop\n            }\n        }, renderedMatches);\n    }\n    return renderedMatches;\n}\nfunction DefaultErrorComponent() {\n    let error = useRouteError();\n    let message = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.isRouteErrorResponse)(error) ? error.status + \" \" + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);\n    let stack = error instanceof Error ? error.stack : null;\n    let lightgrey = \"rgba(200,200,200, 0.5)\";\n    let preStyles = {\n        padding: \"0.5rem\",\n        backgroundColor: lightgrey\n    };\n    let codeStyles = {\n        padding: \"2px 4px\",\n        backgroundColor: lightgrey\n    };\n    let devInfo = null;\n    if (true) {\n        console.error(\"Error handled by React Router default ErrorBoundary:\", error);\n        devInfo = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"p\", null, \"\\uD83D\\uDCBF Hey developer \\uD83D\\uDC4B\"), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"p\", null, \"You can provide a way better UX than this when your app throws errors by providing your own \", /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"code\", {\n            style: codeStyles\n        }, \"ErrorBoundary\"), \" or\", \" \", /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"code\", {\n            style: codeStyles\n        }, \"errorElement\"), \" prop on your route.\"));\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"h2\", null, \"Unexpected Application Error!\"), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"h3\", {\n        style: {\n            fontStyle: \"italic\"\n        }\n    }, message), stack ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"pre\", {\n        style: preStyles\n    }, stack) : null, devInfo);\n}\nconst defaultErrorElement = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(DefaultErrorComponent, null);\nclass RenderErrorBoundary extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n    constructor(props){\n        super(props);\n        this.state = {\n            location: props.location,\n            revalidation: props.revalidation,\n            error: props.error\n        };\n    }\n    static getDerivedStateFromError(error) {\n        return {\n            error: error\n        };\n    }\n    static getDerivedStateFromProps(props, state) {\n        // When we get into an error state, the user will likely click \"back\" to the\n        // previous page that didn't have an error. Because this wraps the entire\n        // application, that will have no effect--the error page continues to display.\n        // This gives us a mechanism to recover from the error when the location changes.\n        //\n        // Whether we're in an error state or not, we update the location in state\n        // so that when we are in an error state, it gets reset when a new location\n        // comes in and the user recovers from the error.\n        if (state.location !== props.location || state.revalidation !== \"idle\" && props.revalidation === \"idle\") {\n            return {\n                error: props.error,\n                location: props.location,\n                revalidation: props.revalidation\n            };\n        }\n        // If we're not changing locations, preserve the location but still surface\n        // any new errors that may come through. We retain the existing error, we do\n        // this because the error provided from the app state may be cleared without\n        // the location changing.\n        return {\n            error: props.error !== undefined ? props.error : state.error,\n            location: state.location,\n            revalidation: props.revalidation || state.revalidation\n        };\n    }\n    componentDidCatch(error, errorInfo) {\n        console.error(\"React Router caught the following error during render\", error, errorInfo);\n    }\n    render() {\n        return this.state.error !== undefined ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RouteContext.Provider, {\n            value: this.props.routeContext\n        }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RouteErrorContext.Provider, {\n            value: this.state.error,\n            children: this.props.component\n        })) : this.props.children;\n    }\n}\nfunction RenderedRoute(_ref) {\n    let { routeContext, match, children } = _ref;\n    let dataRouterContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterContext);\n    // Track how deep we got in our render pass to emulate SSR componentDidCatch\n    // in a DataStaticRouter\n    if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {\n        dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RouteContext.Provider, {\n        value: routeContext\n    }, children);\n}\nfunction _renderMatches(matches, parentMatches, dataRouterState, future) {\n    var _dataRouterState2;\n    if (parentMatches === void 0) {\n        parentMatches = [];\n    }\n    if (dataRouterState === void 0) {\n        dataRouterState = null;\n    }\n    if (future === void 0) {\n        future = null;\n    }\n    if (matches == null) {\n        var _dataRouterState;\n        if ((_dataRouterState = dataRouterState) != null && _dataRouterState.errors) {\n            // Don't bail if we have data router errors so we can render them in the\n            // boundary.  Use the pre-matched (or shimmed) matches\n            matches = dataRouterState.matches;\n        } else {\n            return null;\n        }\n    }\n    let renderedMatches = matches;\n    // If we have data errors, trim matches to the highest error boundary\n    let errors = (_dataRouterState2 = dataRouterState) == null ? void 0 : _dataRouterState2.errors;\n    if (errors != null) {\n        let errorIndex = renderedMatches.findIndex((m)=>m.route.id && (errors == null ? void 0 : errors[m.route.id]));\n        !(errorIndex >= 0) ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"Could not find a matching route for errors on route IDs: \" + Object.keys(errors).join(\",\")) : 0 : void 0;\n        renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));\n    }\n    // If we're in a partial hydration mode, detect if we need to render down to\n    // a given HydrateFallback while we load the rest of the hydration data\n    let renderFallback = false;\n    let fallbackIndex = -1;\n    if (dataRouterState && future && future.v7_partialHydration) {\n        for(let i = 0; i < renderedMatches.length; i++){\n            let match = renderedMatches[i];\n            // Track the deepest fallback up until the first route without data\n            if (match.route.HydrateFallback || match.route.hydrateFallbackElement) {\n                fallbackIndex = i;\n            }\n            if (match.route.id) {\n                let { loaderData, errors } = dataRouterState;\n                let needsToRunLoader = match.route.loader && loaderData[match.route.id] === undefined && (!errors || errors[match.route.id] === undefined);\n                if (match.route.lazy || needsToRunLoader) {\n                    // We found the first route that's not ready to render (waiting on\n                    // lazy, or has a loader that hasn't run yet).  Flag that we need to\n                    // render a fallback and render up until the appropriate fallback\n                    renderFallback = true;\n                    if (fallbackIndex >= 0) {\n                        renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);\n                    } else {\n                        renderedMatches = [\n                            renderedMatches[0]\n                        ];\n                    }\n                    break;\n                }\n            }\n        }\n    }\n    return renderedMatches.reduceRight((outlet, match, index)=>{\n        // Only data routers handle errors/fallbacks\n        let error;\n        let shouldRenderHydrateFallback = false;\n        let errorElement = null;\n        let hydrateFallbackElement = null;\n        if (dataRouterState) {\n            error = errors && match.route.id ? errors[match.route.id] : undefined;\n            errorElement = match.route.errorElement || defaultErrorElement;\n            if (renderFallback) {\n                if (fallbackIndex < 0 && index === 0) {\n                    warningOnce(\"route-fallback\", false, \"No `HydrateFallback` element provided to render during initial hydration\");\n                    shouldRenderHydrateFallback = true;\n                    hydrateFallbackElement = null;\n                } else if (fallbackIndex === index) {\n                    shouldRenderHydrateFallback = true;\n                    hydrateFallbackElement = match.route.hydrateFallbackElement || null;\n                }\n            }\n        }\n        let matches = parentMatches.concat(renderedMatches.slice(0, index + 1));\n        let getChildren = ()=>{\n            let children;\n            if (error) {\n                children = errorElement;\n            } else if (shouldRenderHydrateFallback) {\n                children = hydrateFallbackElement;\n            } else if (match.route.Component) {\n                // Note: This is a de-optimized path since React won't re-use the\n                // ReactElement since it's identity changes with each new\n                // React.createElement call.  We keep this so folks can use\n                // `<Route Component={...}>` in `<Routes>` but generally `Component`\n                // usage is only advised in `RouterProvider` when we can convert it to\n                // `element` ahead of time.\n                children = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(match.route.Component, null);\n            } else if (match.route.element) {\n                children = match.route.element;\n            } else {\n                children = outlet;\n            }\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RenderedRoute, {\n                match: match,\n                routeContext: {\n                    outlet,\n                    matches,\n                    isDataRoute: dataRouterState != null\n                },\n                children: children\n            });\n        };\n        // Only wrap in an error boundary within data router usages when we have an\n        // ErrorBoundary/errorElement on this route.  Otherwise let it bubble up to\n        // an ancestor ErrorBoundary/errorElement\n        return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RenderErrorBoundary, {\n            location: dataRouterState.location,\n            revalidation: dataRouterState.revalidation,\n            component: errorElement,\n            error: error,\n            children: getChildren(),\n            routeContext: {\n                outlet: null,\n                matches,\n                isDataRoute: true\n            }\n        }) : getChildren();\n    }, null);\n}\nvar DataRouterHook = /*#__PURE__*/ function(DataRouterHook) {\n    DataRouterHook[\"UseBlocker\"] = \"useBlocker\";\n    DataRouterHook[\"UseRevalidator\"] = \"useRevalidator\";\n    DataRouterHook[\"UseNavigateStable\"] = \"useNavigate\";\n    return DataRouterHook;\n}(DataRouterHook || {});\nvar DataRouterStateHook = /*#__PURE__*/ function(DataRouterStateHook) {\n    DataRouterStateHook[\"UseBlocker\"] = \"useBlocker\";\n    DataRouterStateHook[\"UseLoaderData\"] = \"useLoaderData\";\n    DataRouterStateHook[\"UseActionData\"] = \"useActionData\";\n    DataRouterStateHook[\"UseRouteError\"] = \"useRouteError\";\n    DataRouterStateHook[\"UseNavigation\"] = \"useNavigation\";\n    DataRouterStateHook[\"UseRouteLoaderData\"] = \"useRouteLoaderData\";\n    DataRouterStateHook[\"UseMatches\"] = \"useMatches\";\n    DataRouterStateHook[\"UseRevalidator\"] = \"useRevalidator\";\n    DataRouterStateHook[\"UseNavigateStable\"] = \"useNavigate\";\n    DataRouterStateHook[\"UseRouteId\"] = \"useRouteId\";\n    return DataRouterStateHook;\n}(DataRouterStateHook || {});\nfunction getDataRouterConsoleError(hookName) {\n    return hookName + \" must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.\";\n}\nfunction useDataRouterContext(hookName) {\n    let ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterContext);\n    !ctx ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, getDataRouterConsoleError(hookName)) : 0 : void 0;\n    return ctx;\n}\nfunction useDataRouterState(hookName) {\n    let state = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterStateContext);\n    !state ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, getDataRouterConsoleError(hookName)) : 0 : void 0;\n    return state;\n}\nfunction useRouteContext(hookName) {\n    let route = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n    !route ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, getDataRouterConsoleError(hookName)) : 0 : void 0;\n    return route;\n}\n// Internal version with hookName-aware debugging\nfunction useCurrentRouteId(hookName) {\n    let route = useRouteContext(hookName);\n    let thisRoute = route.matches[route.matches.length - 1];\n    !thisRoute.route.id ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, hookName + ' can only be used on routes that contain a unique \"id\"') : 0 : void 0;\n    return thisRoute.route.id;\n}\n/**\n * Returns the ID for the nearest contextual route\n */ function useRouteId() {\n    return useCurrentRouteId(DataRouterStateHook.UseRouteId);\n}\n/**\n * Returns the current navigation, defaulting to an \"idle\" navigation when\n * no navigation is in progress\n */ function useNavigation() {\n    let state = useDataRouterState(DataRouterStateHook.UseNavigation);\n    return state.navigation;\n}\n/**\n * Returns a revalidate function for manually triggering revalidation, as well\n * as the current state of any manual revalidations\n */ function useRevalidator() {\n    let dataRouterContext = useDataRouterContext(DataRouterHook.UseRevalidator);\n    let state = useDataRouterState(DataRouterStateHook.UseRevalidator);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            revalidate: dataRouterContext.router.revalidate,\n            state: state.revalidation\n        }), [\n        dataRouterContext.router.revalidate,\n        state.revalidation\n    ]);\n}\n/**\n * Returns the active route matches, useful for accessing loaderData for\n * parent/child routes or the route \"handle\" property\n */ function useMatches() {\n    let { matches, loaderData } = useDataRouterState(DataRouterStateHook.UseMatches);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>matches.map((m)=>(0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_convertRouteMatchToUiMatch)(m, loaderData)), [\n        matches,\n        loaderData\n    ]);\n}\n/**\n * Returns the loader data for the nearest ancestor Route loader\n */ function useLoaderData() {\n    let state = useDataRouterState(DataRouterStateHook.UseLoaderData);\n    let routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);\n    if (state.errors && state.errors[routeId] != null) {\n        console.error(\"You cannot `useLoaderData` in an errorElement (routeId: \" + routeId + \")\");\n        return undefined;\n    }\n    return state.loaderData[routeId];\n}\n/**\n * Returns the loaderData for the given routeId\n */ function useRouteLoaderData(routeId) {\n    let state = useDataRouterState(DataRouterStateHook.UseRouteLoaderData);\n    return state.loaderData[routeId];\n}\n/**\n * Returns the action data for the nearest ancestor Route action\n */ function useActionData() {\n    let state = useDataRouterState(DataRouterStateHook.UseActionData);\n    let routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);\n    return state.actionData ? state.actionData[routeId] : undefined;\n}\n/**\n * Returns the nearest ancestor Route error, which could be a loader/action\n * error or a render error.  This is intended to be called from your\n * ErrorBoundary/errorElement to display a proper error message.\n */ function useRouteError() {\n    var _state$errors;\n    let error = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteErrorContext);\n    let state = useDataRouterState(DataRouterStateHook.UseRouteError);\n    let routeId = useCurrentRouteId(DataRouterStateHook.UseRouteError);\n    // If this was a render error, we put it in a RouteError context inside\n    // of RenderErrorBoundary\n    if (error !== undefined) {\n        return error;\n    }\n    // Otherwise look for errors from our data router state\n    return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];\n}\n/**\n * Returns the happy-path data from the nearest ancestor `<Await />` value\n */ function useAsyncValue() {\n    let value = react__WEBPACK_IMPORTED_MODULE_0__.useContext(AwaitContext);\n    return value == null ? void 0 : value._data;\n}\n/**\n * Returns the error from the nearest ancestor `<Await />` value\n */ function useAsyncError() {\n    let value = react__WEBPACK_IMPORTED_MODULE_0__.useContext(AwaitContext);\n    return value == null ? void 0 : value._error;\n}\nlet blockerId = 0;\n/**\n * Allow the application to block navigations within the SPA and present the\n * user a confirmation dialog to confirm the navigation.  Mostly used to avoid\n * using half-filled form data.  This does not handle hard-reloads or\n * cross-origin navigations.\n */ function useBlocker(shouldBlock) {\n    let { router, basename } = useDataRouterContext(DataRouterHook.UseBlocker);\n    let state = useDataRouterState(DataRouterStateHook.UseBlocker);\n    let [blockerKey, setBlockerKey] = react__WEBPACK_IMPORTED_MODULE_0__.useState(\"\");\n    let blockerFunction = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((arg)=>{\n        if (typeof shouldBlock !== \"function\") {\n            return !!shouldBlock;\n        }\n        if (basename === \"/\") {\n            return shouldBlock(arg);\n        }\n        // If they provided us a function and we've got an active basename, strip\n        // it from the locations we expose to the user to match the behavior of\n        // useLocation\n        let { currentLocation, nextLocation, historyAction } = arg;\n        return shouldBlock({\n            currentLocation: _extends({}, currentLocation, {\n                pathname: (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.stripBasename)(currentLocation.pathname, basename) || currentLocation.pathname\n            }),\n            nextLocation: _extends({}, nextLocation, {\n                pathname: (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.stripBasename)(nextLocation.pathname, basename) || nextLocation.pathname\n            }),\n            historyAction\n        });\n    }, [\n        basename,\n        shouldBlock\n    ]);\n    // This effect is in charge of blocker key assignment and deletion (which is\n    // tightly coupled to the key)\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        let key = String(++blockerId);\n        setBlockerKey(key);\n        return ()=>router.deleteBlocker(key);\n    }, [\n        router\n    ]);\n    // This effect handles assigning the blockerFunction.  This is to handle\n    // unstable blocker function identities, and happens only after the prior\n    // effect so we don't get an orphaned blockerFunction in the router with a\n    // key of \"\".  Until then we just have the IDLE_BLOCKER.\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (blockerKey !== \"\") {\n            router.getBlocker(blockerKey, blockerFunction);\n        }\n    }, [\n        router,\n        blockerKey,\n        blockerFunction\n    ]);\n    // Prefer the blocker from `state` not `router.state` since DataRouterContext\n    // is memoized so this ensures we update on blocker state updates\n    return blockerKey && state.blockers.has(blockerKey) ? state.blockers.get(blockerKey) : _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.IDLE_BLOCKER;\n}\n/**\n * Stable version of useNavigate that is used when we are in the context of\n * a RouterProvider.\n */ function useNavigateStable() {\n    let { router } = useDataRouterContext(DataRouterHook.UseNavigateStable);\n    let id = useCurrentRouteId(DataRouterStateHook.UseNavigateStable);\n    let activeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    useIsomorphicLayoutEffect(()=>{\n        activeRef.current = true;\n    });\n    let navigate = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function(to, options) {\n        if (options === void 0) {\n            options = {};\n        }\n         true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(activeRef.current, navigateEffectWarning) : 0;\n        // Short circuit here since if this happens on first render the navigate\n        // is useless because we haven't wired up our router subscriber yet\n        if (!activeRef.current) return;\n        if (typeof to === \"number\") {\n            router.navigate(to);\n        } else {\n            router.navigate(to, _extends({\n                fromRouteId: id\n            }, options));\n        }\n    }, [\n        router,\n        id\n    ]);\n    return navigate;\n}\nconst alreadyWarned = {};\nfunction warningOnce(key, cond, message) {\n    if (!cond && !alreadyWarned[key]) {\n        alreadyWarned[key] = true;\n         true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(false, message) : 0;\n    }\n}\n/**\n  Webpack + React 17 fails to compile on any of the following because webpack\n  complains that `startTransition` doesn't exist in `React`:\n  * import { startTransition } from \"react\"\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React.startTransition(() => setState()) : setState()\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React[\"startTransition\"](() => setState()) : setState()\n\n  Moving it to a constant such as the following solves the Webpack/React 17 issue:\n  * import * as React from from \"react\";\n    const START_TRANSITION = \"startTransition\";\n    START_TRANSITION in React ? React[START_TRANSITION](() => setState()) : setState()\n\n  However, that introduces webpack/terser minification issues in production builds\n  in React 18 where minification/obfuscation ends up removing the call of\n  React.startTransition entirely from the first half of the ternary.  Grabbing\n  this exported reference once up front resolves that issue.\n\n  See https://github.com/remix-run/react-router/issues/10579\n*/ const START_TRANSITION = \"startTransition\";\nconst startTransitionImpl = react__WEBPACK_IMPORTED_MODULE_0__[START_TRANSITION];\n/**\n * Given a Remix Router instance, render the appropriate UI\n */ function RouterProvider(_ref) {\n    let { fallbackElement, router, future } = _ref;\n    let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState(router.state);\n    let { v7_startTransition } = future || {};\n    let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newState)=>{\n        if (v7_startTransition && startTransitionImpl) {\n            startTransitionImpl(()=>setStateImpl(newState));\n        } else {\n            setStateImpl(newState);\n        }\n    }, [\n        setStateImpl,\n        v7_startTransition\n    ]);\n    // Need to use a layout effect here so we are subscribed early enough to\n    // pick up on any render-driven redirects/navigations (useEffect/<Navigate>)\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>router.subscribe(setState), [\n        router,\n        setState\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n         true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(fallbackElement == null || !router.future.v7_partialHydration, \"`<RouterProvider fallbackElement>` is deprecated when using \" + \"`v7_partialHydration`, use a `HydrateFallback` component instead\") : 0;\n    // Only log this once on initial mount\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    let navigator = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        return {\n            createHref: router.createHref,\n            encodeLocation: router.encodeLocation,\n            go: (n)=>router.navigate(n),\n            push: (to, state, opts)=>router.navigate(to, {\n                    state,\n                    preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n                }),\n            replace: (to, state, opts)=>router.navigate(to, {\n                    replace: true,\n                    state,\n                    preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n                })\n        };\n    }, [\n        router\n    ]);\n    let basename = router.basename || \"/\";\n    let dataRouterContext = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            router,\n            navigator,\n            static: false,\n            basename\n        }), [\n        router,\n        navigator,\n        basename\n    ]);\n    // The fragment and {null} here are important!  We need them to keep React 18's\n    // useId happy when we are server-rendering since we may have a <script> here\n    // containing the hydrated server-side staticContext (from StaticRouterProvider).\n    // useId relies on the component tree structure to generate deterministic id's\n    // so we need to ensure it remains the same on the client even though\n    // we don't need the <script> tag\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataRouterContext.Provider, {\n        value: dataRouterContext\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataRouterStateContext.Provider, {\n        value: state\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Router, {\n        basename: basename,\n        location: state.location,\n        navigationType: state.historyAction,\n        navigator: navigator,\n        future: {\n            v7_relativeSplatPath: router.future.v7_relativeSplatPath\n        }\n    }, state.initialized || router.future.v7_partialHydration ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataRoutes, {\n        routes: router.routes,\n        future: router.future,\n        state: state\n    }) : fallbackElement))), null);\n}\nfunction DataRoutes(_ref2) {\n    let { routes, future, state } = _ref2;\n    return useRoutesImpl(routes, undefined, state, future);\n}\n/**\n * A `<Router>` that stores all entries in memory.\n *\n * @see https://reactrouter.com/router-components/memory-router\n */ function MemoryRouter(_ref3) {\n    let { basename, children, initialEntries, initialIndex, future } = _ref3;\n    let historyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    if (historyRef.current == null) {\n        historyRef.current = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.createMemoryHistory)({\n            initialEntries,\n            initialIndex,\n            v5Compat: true\n        });\n    }\n    let history = historyRef.current;\n    let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        action: history.action,\n        location: history.location\n    });\n    let { v7_startTransition } = future || {};\n    let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newState)=>{\n        v7_startTransition && startTransitionImpl ? startTransitionImpl(()=>setStateImpl(newState)) : setStateImpl(newState);\n    }, [\n        setStateImpl,\n        v7_startTransition\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>history.listen(setState), [\n        history,\n        setState\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Router, {\n        basename: basename,\n        children: children,\n        location: state.location,\n        navigationType: state.action,\n        navigator: history,\n        future: future\n    });\n}\n/**\n * Changes the current location.\n *\n * Note: This API is mostly useful in React.Component subclasses that are not\n * able to use hooks. In functional components, we recommend you use the\n * `useNavigate` hook instead.\n *\n * @see https://reactrouter.com/components/navigate\n */ function Navigate(_ref4) {\n    let { to, replace, state, relative } = _ref4;\n    !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, // the router loaded. We can help them understand how to avoid that.\n    \"<Navigate> may be used only in the context of a <Router> component.\") : 0 : void 0;\n    let { future, static: isStatic } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);\n     true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(!isStatic, \"<Navigate> must not be used on the initial render in a <StaticRouter>. \" + \"This is a no-op, but you should modify your code so the <Navigate> is \" + \"only ever rendered in response to some user interaction or state change.\") : 0;\n    let { matches } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n    let { pathname: locationPathname } = useLocation();\n    let navigate = useNavigate();\n    // Resolve the path outside of the effect so that when effects run twice in\n    // StrictMode they navigate to the same place\n    let path = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.resolveTo)(to, (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_getResolveToMatches)(matches, future.v7_relativeSplatPath), locationPathname, relative === \"path\");\n    let jsonPath = JSON.stringify(path);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>navigate(JSON.parse(jsonPath), {\n            replace,\n            state,\n            relative\n        }), [\n        navigate,\n        jsonPath,\n        relative,\n        replace,\n        state\n    ]);\n    return null;\n}\n/**\n * Renders the child route's element, if there is one.\n *\n * @see https://reactrouter.com/components/outlet\n */ function Outlet(props) {\n    return useOutlet(props.context);\n}\n/**\n * Declares an element that should be rendered at a certain URL path.\n *\n * @see https://reactrouter.com/components/route\n */ function Route(_props) {\n     true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"A <Route> is only ever to be used as the child of <Routes> element, \" + \"never rendered directly. Please wrap your <Route> in a <Routes>.\") : 0;\n}\n/**\n * Provides location context for the rest of the app.\n *\n * Note: You usually won't render a `<Router>` directly. Instead, you'll render a\n * router that is more specific to your environment such as a `<BrowserRouter>`\n * in web browsers or a `<StaticRouter>` for server rendering.\n *\n * @see https://reactrouter.com/router-components/router\n */ function Router(_ref5) {\n    let { basename: basenameProp = \"/\", children = null, location: locationProp, navigationType = _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.Action.Pop, navigator, static: staticProp = false, future } = _ref5;\n    !!useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"You cannot render a <Router> inside another <Router>.\" + \" You should never have more than one in your app.\") : 0 : void 0;\n    // Preserve trailing slashes on basename, so we can let the user control\n    // the enforcement of trailing slashes throughout the app\n    let basename = basenameProp.replace(/^\\/*/, \"/\");\n    let navigationContext = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            basename,\n            navigator,\n            static: staticProp,\n            future: _extends({\n                v7_relativeSplatPath: false\n            }, future)\n        }), [\n        basename,\n        future,\n        navigator,\n        staticProp\n    ]);\n    if (typeof locationProp === \"string\") {\n        locationProp = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.parsePath)(locationProp);\n    }\n    let { pathname = \"/\", search = \"\", hash = \"\", state = null, key = \"default\" } = locationProp;\n    let locationContext = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        let trailingPathname = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.stripBasename)(pathname, basename);\n        if (trailingPathname == null) {\n            return null;\n        }\n        return {\n            location: {\n                pathname: trailingPathname,\n                search,\n                hash,\n                state,\n                key\n            },\n            navigationType\n        };\n    }, [\n        basename,\n        pathname,\n        search,\n        hash,\n        state,\n        key,\n        navigationType\n    ]);\n     true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(locationContext != null, '<Router basename=\"' + basename + '\"> is not able to match the URL ' + ('\"' + pathname + search + hash + '\" because it does not start with the ') + \"basename, so the <Router> won't render anything.\") : 0;\n    if (locationContext == null) {\n        return null;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(NavigationContext.Provider, {\n        value: navigationContext\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(LocationContext.Provider, {\n        children: children,\n        value: locationContext\n    }));\n}\n/**\n * A container for a nested tree of `<Route>` elements that renders the branch\n * that best matches the current location.\n *\n * @see https://reactrouter.com/components/routes\n */ function Routes(_ref6) {\n    let { children, location } = _ref6;\n    return useRoutes(createRoutesFromChildren(children), location);\n}\n/**\n * Component to use for rendering lazily loaded data from returning defer()\n * in a loader function\n */ function Await(_ref7) {\n    let { children, errorElement, resolve } = _ref7;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(AwaitErrorBoundary, {\n        resolve: resolve,\n        errorElement: errorElement\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ResolveAwait, null, children));\n}\nvar AwaitRenderStatus = /*#__PURE__*/ function(AwaitRenderStatus) {\n    AwaitRenderStatus[AwaitRenderStatus[\"pending\"] = 0] = \"pending\";\n    AwaitRenderStatus[AwaitRenderStatus[\"success\"] = 1] = \"success\";\n    AwaitRenderStatus[AwaitRenderStatus[\"error\"] = 2] = \"error\";\n    return AwaitRenderStatus;\n}(AwaitRenderStatus || {});\nconst neverSettledPromise = new Promise(()=>{});\nclass AwaitErrorBoundary extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n    constructor(props){\n        super(props);\n        this.state = {\n            error: null\n        };\n    }\n    static getDerivedStateFromError(error) {\n        return {\n            error\n        };\n    }\n    componentDidCatch(error, errorInfo) {\n        console.error(\"<Await> caught the following error during render\", error, errorInfo);\n    }\n    render() {\n        let { children, errorElement, resolve } = this.props;\n        let promise = null;\n        let status = AwaitRenderStatus.pending;\n        if (!(resolve instanceof Promise)) {\n            // Didn't get a promise - provide as a resolved promise\n            status = AwaitRenderStatus.success;\n            promise = Promise.resolve();\n            Object.defineProperty(promise, \"_tracked\", {\n                get: ()=>true\n            });\n            Object.defineProperty(promise, \"_data\", {\n                get: ()=>resolve\n            });\n        } else if (this.state.error) {\n            // Caught a render error, provide it as a rejected promise\n            status = AwaitRenderStatus.error;\n            let renderError = this.state.error;\n            promise = Promise.reject().catch(()=>{}); // Avoid unhandled rejection warnings\n            Object.defineProperty(promise, \"_tracked\", {\n                get: ()=>true\n            });\n            Object.defineProperty(promise, \"_error\", {\n                get: ()=>renderError\n            });\n        } else if (resolve._tracked) {\n            // Already tracked promise - check contents\n            promise = resolve;\n            status = promise._error !== undefined ? AwaitRenderStatus.error : promise._data !== undefined ? AwaitRenderStatus.success : AwaitRenderStatus.pending;\n        } else {\n            // Raw (untracked) promise - track it\n            status = AwaitRenderStatus.pending;\n            Object.defineProperty(resolve, \"_tracked\", {\n                get: ()=>true\n            });\n            promise = resolve.then((data)=>Object.defineProperty(resolve, \"_data\", {\n                    get: ()=>data\n                }), (error)=>Object.defineProperty(resolve, \"_error\", {\n                    get: ()=>error\n                }));\n        }\n        if (status === AwaitRenderStatus.error && promise._error instanceof _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.AbortedDeferredError) {\n            // Freeze the UI by throwing a never resolved promise\n            throw neverSettledPromise;\n        }\n        if (status === AwaitRenderStatus.error && !errorElement) {\n            // No errorElement, throw to the nearest route-level error boundary\n            throw promise._error;\n        }\n        if (status === AwaitRenderStatus.error) {\n            // Render via our errorElement\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(AwaitContext.Provider, {\n                value: promise,\n                children: errorElement\n            });\n        }\n        if (status === AwaitRenderStatus.success) {\n            // Render children with resolved value\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(AwaitContext.Provider, {\n                value: promise,\n                children: children\n            });\n        }\n        // Throw to the suspense boundary\n        throw promise;\n    }\n}\n/**\n * @private\n * Indirection to leverage useAsyncValue for a render-prop API on `<Await>`\n */ function ResolveAwait(_ref8) {\n    let { children } = _ref8;\n    let data = useAsyncValue();\n    let toRender = typeof children === \"function\" ? children(data) : children;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, toRender);\n}\n///////////////////////////////////////////////////////////////////////////////\n// UTILS\n///////////////////////////////////////////////////////////////////////////////\n/**\n * Creates a route config from a React \"children\" object, which is usually\n * either a `<Route>` element or an array of them. Used internally by\n * `<Routes>` to create a route config from its children.\n *\n * @see https://reactrouter.com/utils/create-routes-from-children\n */ function createRoutesFromChildren(children, parentPath) {\n    if (parentPath === void 0) {\n        parentPath = [];\n    }\n    let routes = [];\n    react__WEBPACK_IMPORTED_MODULE_0__.Children.forEach(children, (element, index)=>{\n        if (!/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(element)) {\n            // Ignore non-elements. This allows people to more easily inline\n            // conditionals in their route config.\n            return;\n        }\n        let treePath = [\n            ...parentPath,\n            index\n        ];\n        if (element.type === react__WEBPACK_IMPORTED_MODULE_0__.Fragment) {\n            // Transparently support React.Fragment and its children.\n            routes.push.apply(routes, createRoutesFromChildren(element.props.children, treePath));\n            return;\n        }\n        !(element.type === Route) ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"[\" + (typeof element.type === \"string\" ? element.type : element.type.name) + \"] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>\") : 0 : void 0;\n        !(!element.props.index || !element.props.children) ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"An index route cannot have child routes.\") : 0 : void 0;\n        let route = {\n            id: element.props.id || treePath.join(\"-\"),\n            caseSensitive: element.props.caseSensitive,\n            element: element.props.element,\n            Component: element.props.Component,\n            index: element.props.index,\n            path: element.props.path,\n            loader: element.props.loader,\n            action: element.props.action,\n            errorElement: element.props.errorElement,\n            ErrorBoundary: element.props.ErrorBoundary,\n            hasErrorBoundary: element.props.ErrorBoundary != null || element.props.errorElement != null,\n            shouldRevalidate: element.props.shouldRevalidate,\n            handle: element.props.handle,\n            lazy: element.props.lazy\n        };\n        if (element.props.children) {\n            route.children = createRoutesFromChildren(element.props.children, treePath);\n        }\n        routes.push(route);\n    });\n    return routes;\n}\n/**\n * Renders the result of `matchRoutes()` into a React element.\n */ function renderMatches(matches) {\n    return _renderMatches(matches);\n}\nfunction mapRouteProperties(route) {\n    let updates = {\n        // Note: this check also occurs in createRoutesFromChildren so update\n        // there if you change this -- please and thank you!\n        hasErrorBoundary: route.ErrorBoundary != null || route.errorElement != null\n    };\n    if (route.Component) {\n        if (true) {\n            if (route.element) {\n                 true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(false, \"You should not include both `Component` and `element` on your route - \" + \"`Component` will be used.\") : 0;\n            }\n        }\n        Object.assign(updates, {\n            element: /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(route.Component),\n            Component: undefined\n        });\n    }\n    if (route.HydrateFallback) {\n        if (true) {\n            if (route.hydrateFallbackElement) {\n                 true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(false, \"You should not include both `HydrateFallback` and `hydrateFallbackElement` on your route - \" + \"`HydrateFallback` will be used.\") : 0;\n            }\n        }\n        Object.assign(updates, {\n            hydrateFallbackElement: /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(route.HydrateFallback),\n            HydrateFallback: undefined\n        });\n    }\n    if (route.ErrorBoundary) {\n        if (true) {\n            if (route.errorElement) {\n                 true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(false, \"You should not include both `ErrorBoundary` and `errorElement` on your route - \" + \"`ErrorBoundary` will be used.\") : 0;\n            }\n        }\n        Object.assign(updates, {\n            errorElement: /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(route.ErrorBoundary),\n            ErrorBoundary: undefined\n        });\n    }\n    return updates;\n}\nfunction createMemoryRouter(routes, opts) {\n    return (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.createRouter)({\n        basename: opts == null ? void 0 : opts.basename,\n        future: _extends({}, opts == null ? void 0 : opts.future, {\n            v7_prependBasename: true\n        }),\n        history: (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.createMemoryHistory)({\n            initialEntries: opts == null ? void 0 : opts.initialEntries,\n            initialIndex: opts == null ? void 0 : opts.initialIndex\n        }),\n        hydrationData: opts == null ? void 0 : opts.hydrationData,\n        routes,\n        mapRouteProperties\n    }).initialize();\n}\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Q0FTQyxHQUM4QjtBQUNrUjtBQUNyRjtBQUU1TixTQUFTeUI7SUFDUEEsV0FBV0MsT0FBT0MsTUFBTSxHQUFHRCxPQUFPQyxNQUFNLENBQUNDLElBQUksS0FBSyxTQUFVQyxNQUFNO1FBQ2hFLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJQyxVQUFVQyxNQUFNLEVBQUVGLElBQUs7WUFDekMsSUFBSUcsU0FBU0YsU0FBUyxDQUFDRCxFQUFFO1lBQ3pCLElBQUssSUFBSUksT0FBT0QsT0FBUTtnQkFDdEIsSUFBSVAsT0FBT1MsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ0osUUFBUUMsTUFBTTtvQkFDckRMLE1BQU0sQ0FBQ0ssSUFBSSxHQUFHRCxNQUFNLENBQUNDLElBQUk7Z0JBQzNCO1lBQ0Y7UUFDRjtRQUNBLE9BQU9MO0lBQ1Q7SUFDQSxPQUFPSixTQUFTYSxLQUFLLENBQUMsSUFBSSxFQUFFUDtBQUM5QjtBQUVBLDhFQUE4RTtBQUM5RSwyQkFBMkI7QUFDM0IsTUFBTVEsb0JBQW9CLFdBQVcsR0FBRXZDLGdEQUFtQixDQUFDO0FBQzNELElBQUl5QyxJQUFxQyxFQUFFO0lBQ3pDRixrQkFBa0JHLFdBQVcsR0FBRztBQUNsQztBQUNBLE1BQU1DLHlCQUF5QixXQUFXLEdBQUUzQyxnREFBbUIsQ0FBQztBQUNoRSxJQUFJeUMsSUFBcUMsRUFBRTtJQUN6Q0UsdUJBQXVCRCxXQUFXLEdBQUc7QUFDdkM7QUFDQSxNQUFNRSxlQUFlLFdBQVcsR0FBRTVDLGdEQUFtQixDQUFDO0FBQ3RELElBQUl5QyxJQUFxQyxFQUFFO0lBQ3pDRyxhQUFhRixXQUFXLEdBQUc7QUFDN0I7QUFFQTs7Ozs7Ozs7Q0FRQyxHQUVELE1BQU1HLG9CQUFvQixXQUFXLEdBQUU3QyxnREFBbUIsQ0FBQztBQUMzRCxJQUFJeUMsSUFBcUMsRUFBRTtJQUN6Q0ksa0JBQWtCSCxXQUFXLEdBQUc7QUFDbEM7QUFDQSxNQUFNSSxrQkFBa0IsV0FBVyxHQUFFOUMsZ0RBQW1CLENBQUM7QUFDekQsSUFBSXlDLElBQXFDLEVBQUU7SUFDekNLLGdCQUFnQkosV0FBVyxHQUFHO0FBQ2hDO0FBQ0EsTUFBTUssZUFBZSxXQUFXLEdBQUUvQyxnREFBbUIsQ0FBQztJQUNwRGdELFFBQVE7SUFDUkMsU0FBUyxFQUFFO0lBQ1hDLGFBQWE7QUFDZjtBQUNBLElBQUlULElBQXFDLEVBQUU7SUFDekNNLGFBQWFMLFdBQVcsR0FBRztBQUM3QjtBQUNBLE1BQU1TLG9CQUFvQixXQUFXLEdBQUVuRCxnREFBbUIsQ0FBQztBQUMzRCxJQUFJeUMsSUFBcUMsRUFBRTtJQUN6Q1Usa0JBQWtCVCxXQUFXLEdBQUc7QUFDbEM7QUFFQTs7Ozs7Q0FLQyxHQUNELFNBQVNVLFFBQVFDLEVBQUUsRUFBRUMsS0FBSztJQUN4QixJQUFJLEVBQ0ZDLFFBQVEsRUFDVCxHQUFHRCxVQUFVLEtBQUssSUFBSSxDQUFDLElBQUlBO0lBQzVCLENBQUNFLHVCQUF1QmYsS0FBcUMsR0FBR3hDLG1FQUFnQkEsQ0FBQyxPQUNqRixnRUFBZ0U7SUFDaEUsd0VBQXdFQSxDQUF1QixHQUFHLEtBQUs7SUFDdkcsSUFBSSxFQUNGd0QsUUFBUSxFQUNSQyxTQUFTLEVBQ1YsR0FBRzFELDZDQUFnQixDQUFDNkM7SUFDckIsSUFBSSxFQUNGZSxJQUFJLEVBQ0pDLFFBQVEsRUFDUkMsTUFBTSxFQUNQLEdBQUdDLGdCQUFnQlYsSUFBSTtRQUN0QkU7SUFDRjtJQUNBLElBQUlTLGlCQUFpQkg7SUFFckIseUVBQXlFO0lBQ3pFLDZFQUE2RTtJQUM3RSw0RUFBNEU7SUFDNUUsb0NBQW9DO0lBQ3BDLElBQUlKLGFBQWEsS0FBSztRQUNwQk8saUJBQWlCSCxhQUFhLE1BQU1KLFdBQVd2RCw0REFBU0EsQ0FBQztZQUFDdUQ7WUFBVUk7U0FBUztJQUMvRTtJQUNBLE9BQU9ILFVBQVVPLFVBQVUsQ0FBQztRQUMxQkosVUFBVUc7UUFDVkY7UUFDQUY7SUFDRjtBQUNGO0FBRUE7Ozs7Q0FJQyxHQUNELFNBQVNKO0lBQ1AsT0FBT3hELDZDQUFnQixDQUFDOEMsb0JBQW9CO0FBQzlDO0FBRUE7Ozs7Ozs7OztDQVNDLEdBQ0QsU0FBU29CO0lBQ1AsQ0FBQ1YsdUJBQXVCZixLQUFxQyxHQUFHeEMsbUVBQWdCQSxDQUFDLE9BQ2pGLGdFQUFnRTtJQUNoRSw0RUFBNEVBLENBQXVCLEdBQUcsS0FBSztJQUMzRyxPQUFPRCw2Q0FBZ0IsQ0FBQzhDLGlCQUFpQnFCLFFBQVE7QUFDbkQ7QUFFQTs7Ozs7Q0FLQyxHQUNELFNBQVNDO0lBQ1AsT0FBT3BFLDZDQUFnQixDQUFDOEMsaUJBQWlCdUIsY0FBYztBQUN6RDtBQUVBOzs7Ozs7Q0FNQyxHQUNELFNBQVNDLFNBQVNDLE9BQU87SUFDdkIsQ0FBQ2YsdUJBQXVCZixLQUFxQyxHQUFHeEMsbUVBQWdCQSxDQUFDLE9BQ2pGLGdFQUFnRTtJQUNoRSx5RUFBeUVBLENBQXVCLEdBQUcsS0FBSztJQUN4RyxJQUFJLEVBQ0Y0RCxRQUFRLEVBQ1QsR0FBR0s7SUFDSixPQUFPbEUsMENBQWEsQ0FBQyxJQUFNRyw0REFBU0EsQ0FBQ29FLFNBQVNWLFdBQVc7UUFBQ0E7UUFBVVU7S0FBUTtBQUM5RTtBQUVBOztDQUVDLEdBRUQsTUFBTUUsd0JBQXdCLGlFQUFpRTtBQUUvRiw2REFBNkQ7QUFDN0QsU0FBU0MsMEJBQTBCQyxFQUFFO0lBQ25DLElBQUlDLFdBQVc1RSw2Q0FBZ0IsQ0FBQzZDLG1CQUFtQmdDLE1BQU07SUFDekQsSUFBSSxDQUFDRCxVQUFVO1FBQ2IsbUVBQW1FO1FBQ25FLG9EQUFvRDtRQUNwRCxzREFBc0Q7UUFDdEQ1RSxrREFBcUIsQ0FBQzJFO0lBQ3hCO0FBQ0Y7QUFFQTs7Ozs7Q0FLQyxHQUNELFNBQVNJO0lBQ1AsSUFBSSxFQUNGN0IsV0FBVyxFQUNaLEdBQUdsRCw2Q0FBZ0IsQ0FBQytDO0lBQ3JCLDRFQUE0RTtJQUM1RSxzREFBc0Q7SUFDdEQsT0FBT0csY0FBYzhCLHNCQUFzQkM7QUFDN0M7QUFDQSxTQUFTQTtJQUNQLENBQUN6Qix1QkFBdUJmLEtBQXFDLEdBQUd4QyxtRUFBZ0JBLENBQUMsT0FDakYsZ0VBQWdFO0lBQ2hFLDRFQUE0RUEsQ0FBdUIsR0FBRyxLQUFLO0lBQzNHLElBQUlpRixvQkFBb0JsRiw2Q0FBZ0IsQ0FBQ3VDO0lBQ3pDLElBQUksRUFDRmtCLFFBQVEsRUFDUjBCLE1BQU0sRUFDTnpCLFNBQVMsRUFDVixHQUFHMUQsNkNBQWdCLENBQUM2QztJQUNyQixJQUFJLEVBQ0ZJLE9BQU8sRUFDUixHQUFHakQsNkNBQWdCLENBQUMrQztJQUNyQixJQUFJLEVBQ0ZjLFVBQVV1QixnQkFBZ0IsRUFDM0IsR0FBR2xCO0lBQ0osSUFBSW1CLHFCQUFxQkMsS0FBS0MsU0FBUyxDQUFDbkYsNkVBQTBCQSxDQUFDNkMsU0FBU2tDLE9BQU9LLG9CQUFvQjtJQUN2RyxJQUFJQyxZQUFZekYseUNBQVksQ0FBQztJQUM3QjBFLDBCQUEwQjtRQUN4QmUsVUFBVUUsT0FBTyxHQUFHO0lBQ3RCO0lBQ0EsSUFBSUMsV0FBVzVGLDhDQUFpQixDQUFDLFNBQVVxRCxFQUFFLEVBQUV5QyxPQUFPO1FBQ3BELElBQUlBLFlBQVksS0FBSyxHQUFHO1lBQ3RCQSxVQUFVLENBQUM7UUFDYjtRQS9OSixLQWdPeUMsR0FBR3pGLGlFQUFjQSxDQUFDb0YsVUFBVUUsT0FBTyxFQUFFbEIseUJBQXlCLENBQU07UUFFekcsd0VBQXdFO1FBQ3hFLGtFQUFrRTtRQUNsRSxJQUFJLENBQUNnQixVQUFVRSxPQUFPLEVBQUU7UUFDeEIsSUFBSSxPQUFPdEMsT0FBTyxVQUFVO1lBQzFCSyxVQUFVcUMsRUFBRSxDQUFDMUM7WUFDYjtRQUNGO1FBQ0EsSUFBSTJDLE9BQU8xRiw0REFBU0EsQ0FBQytDLElBQUlpQyxLQUFLVyxLQUFLLENBQUNaLHFCQUFxQkQsa0JBQWtCVSxRQUFRdkMsUUFBUSxLQUFLO1FBRWhHLHlFQUF5RTtRQUN6RSxxRUFBcUU7UUFDckUsOERBQThEO1FBQzlELHFFQUFxRTtRQUNyRSx3RUFBd0U7UUFDeEUsK0JBQStCO1FBQy9CLElBQUkyQixxQkFBcUIsUUFBUXpCLGFBQWEsS0FBSztZQUNqRHVDLEtBQUtuQyxRQUFRLEdBQUdtQyxLQUFLbkMsUUFBUSxLQUFLLE1BQU1KLFdBQVd2RCw0REFBU0EsQ0FBQztnQkFBQ3VEO2dCQUFVdUMsS0FBS25DLFFBQVE7YUFBQztRQUN4RjtRQUNDLEVBQUMsQ0FBQ2lDLFFBQVFJLE9BQU8sR0FBR3hDLFVBQVV3QyxPQUFPLEdBQUd4QyxVQUFVeUMsSUFBSSxFQUFFSCxNQUFNRixRQUFRTSxLQUFLLEVBQUVOO0lBQ2hGLEdBQUc7UUFBQ3JDO1FBQVVDO1FBQVcyQjtRQUFvQkQ7UUFBa0JGO0tBQWtCO0lBQ2pGLE9BQU9VO0FBQ1Q7QUFDQSxNQUFNUyxnQkFBZ0IsV0FBVyxHQUFFckcsZ0RBQW1CLENBQUM7QUFFdkQ7Ozs7Q0FJQyxHQUNELFNBQVNzRztJQUNQLE9BQU90Ryw2Q0FBZ0IsQ0FBQ3FHO0FBQzFCO0FBRUE7Ozs7O0NBS0MsR0FDRCxTQUFTRSxVQUFVQyxPQUFPO0lBQ3hCLElBQUl4RCxTQUFTaEQsNkNBQWdCLENBQUMrQyxjQUFjQyxNQUFNO0lBQ2xELElBQUlBLFFBQVE7UUFDVixPQUFPLFdBQVcsR0FBRWhELGdEQUFtQixDQUFDcUcsY0FBY0ssUUFBUSxFQUFFO1lBQzlEQyxPQUFPSDtRQUNULEdBQUd4RDtJQUNMO0lBQ0EsT0FBT0E7QUFDVDtBQUVBOzs7OztDQUtDLEdBQ0QsU0FBUzREO0lBQ1AsSUFBSSxFQUNGM0QsT0FBTyxFQUNSLEdBQUdqRCw2Q0FBZ0IsQ0FBQytDO0lBQ3JCLElBQUk4RCxhQUFhNUQsT0FBTyxDQUFDQSxRQUFRakIsTUFBTSxHQUFHLEVBQUU7SUFDNUMsT0FBTzZFLGFBQWFBLFdBQVdDLE1BQU0sR0FBRyxDQUFDO0FBQzNDO0FBRUE7Ozs7Q0FJQyxHQUNELFNBQVMvQyxnQkFBZ0JWLEVBQUUsRUFBRTBELE1BQU07SUFDakMsSUFBSSxFQUNGeEQsUUFBUSxFQUNULEdBQUd3RCxXQUFXLEtBQUssSUFBSSxDQUFDLElBQUlBO0lBQzdCLElBQUksRUFDRjVCLE1BQU0sRUFDUCxHQUFHbkYsNkNBQWdCLENBQUM2QztJQUNyQixJQUFJLEVBQ0ZJLE9BQU8sRUFDUixHQUFHakQsNkNBQWdCLENBQUMrQztJQUNyQixJQUFJLEVBQ0ZjLFVBQVV1QixnQkFBZ0IsRUFDM0IsR0FBR2xCO0lBQ0osSUFBSW1CLHFCQUFxQkMsS0FBS0MsU0FBUyxDQUFDbkYsNkVBQTBCQSxDQUFDNkMsU0FBU2tDLE9BQU9LLG9CQUFvQjtJQUN2RyxPQUFPeEYsMENBQWEsQ0FBQyxJQUFNTSw0REFBU0EsQ0FBQytDLElBQUlpQyxLQUFLVyxLQUFLLENBQUNaLHFCQUFxQkQsa0JBQWtCN0IsYUFBYSxTQUFTO1FBQUNGO1FBQUlnQztRQUFvQkQ7UUFBa0I3QjtLQUFTO0FBQ3ZLO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNELFNBQVN5RCxVQUFVQyxNQUFNLEVBQUVDLFdBQVc7SUFDcEMsT0FBT0MsY0FBY0YsUUFBUUM7QUFDL0I7QUFFQSw4RUFBOEU7QUFDOUUsU0FBU0MsY0FBY0YsTUFBTSxFQUFFQyxXQUFXLEVBQUVFLGVBQWUsRUFBRWpDLE1BQU07SUFDakUsQ0FBQzNCLHVCQUF1QmYsS0FBcUMsR0FBR3hDLG1FQUFnQkEsQ0FBQyxPQUNqRixnRUFBZ0U7SUFDaEUsMEVBQTBFQSxDQUF1QixHQUFHLEtBQUs7SUFDekcsSUFBSSxFQUNGeUQsU0FBUyxFQUNWLEdBQUcxRCw2Q0FBZ0IsQ0FBQzZDO0lBQ3JCLElBQUksRUFDRkksU0FBU29FLGFBQWEsRUFDdkIsR0FBR3JILDZDQUFnQixDQUFDK0M7SUFDckIsSUFBSThELGFBQWFRLGFBQWEsQ0FBQ0EsY0FBY3JGLE1BQU0sR0FBRyxFQUFFO0lBQ3hELElBQUlzRixlQUFlVCxhQUFhQSxXQUFXQyxNQUFNLEdBQUcsQ0FBQztJQUNyRCxJQUFJUyxpQkFBaUJWLGFBQWFBLFdBQVdoRCxRQUFRLEdBQUc7SUFDeEQsSUFBSTJELHFCQUFxQlgsYUFBYUEsV0FBV1ksWUFBWSxHQUFHO0lBQ2hFLElBQUlDLGNBQWNiLGNBQWNBLFdBQVdjLEtBQUs7SUFDaEQsSUFBSWxGLElBQXFDLEVBQUU7UUFDekMscUVBQXFFO1FBQ3JFLDBFQUEwRTtRQUMxRSxxRUFBcUU7UUFDckUsRUFBRTtRQUNGLFdBQVc7UUFDWCxFQUFFO1FBQ0YsV0FBVztRQUNYLDJEQUEyRDtRQUMzRCwrQ0FBK0M7UUFDL0MsNkNBQTZDO1FBQzdDLHNEQUFzRDtRQUN0RCxZQUFZO1FBQ1osRUFBRTtRQUNGLG9CQUFvQjtRQUNwQixhQUFhO1FBQ2IsZUFBZTtRQUNmLHFEQUFxRDtRQUNyRCxnQkFBZ0I7UUFDaEIsT0FBTztRQUNQLElBQUk7UUFDSixJQUFJbUYsYUFBYUYsZUFBZUEsWUFBWTFCLElBQUksSUFBSTtRQUNwRDZCLFlBQVlOLGdCQUFnQixDQUFDRyxlQUFlRSxXQUFXRSxRQUFRLENBQUMsTUFBTSxtRUFBb0UsT0FBT1AsaUJBQWlCLDJCQUE2QkssYUFBYSxjQUFjLElBQUssdUVBQXlFLG9FQUFvRSxrQ0FBbUMsNENBQTRDQSxhQUFhLGVBQWUsSUFBTSxZQUFhQSxDQUFBQSxlQUFlLE1BQU0sTUFBTUEsYUFBYSxJQUFHLElBQUssS0FBSztJQUNqaUI7SUFDQSxJQUFJRyxzQkFBc0I3RDtJQUMxQixJQUFJQztJQUNKLElBQUkrQyxhQUFhO1FBQ2YsSUFBSWM7UUFDSixJQUFJQyxvQkFBb0IsT0FBT2YsZ0JBQWdCLFdBQVczRyw0REFBU0EsQ0FBQzJHLGVBQWVBO1FBQ25GLENBQUVNLENBQUFBLHVCQUF1QixPQUFRLEVBQUNRLHdCQUF3QkMsa0JBQWtCcEUsUUFBUSxLQUFLLE9BQU8sS0FBSyxJQUFJbUUsc0JBQXNCRSxVQUFVLENBQUNWLG1CQUFrQixDQUFDLElBQUsvRSxLQUFxQyxHQUFHeEMsbUVBQWdCQSxDQUFDLE9BQU8sOEZBQThGLG9GQUFxRixrRUFBa0V1SCxxQkFBcUIsSUFBSSxJQUFNLG9CQUFvQlMsa0JBQWtCcEUsUUFBUSxHQUFHLHFDQUFxQyxLQUFNNUQsQ0FBdUIsR0FBRyxLQUFLO1FBQ2puQmtFLFdBQVc4RDtJQUNiLE9BQU87UUFDTDlELFdBQVc0RDtJQUNiO0lBQ0EsSUFBSWxFLFdBQVdNLFNBQVNOLFFBQVEsSUFBSTtJQUNwQyxJQUFJc0Usb0JBQW9CWCx1QkFBdUIsTUFBTTNELFdBQVdBLFNBQVN1RSxLQUFLLENBQUNaLG1CQUFtQnhGLE1BQU0sS0FBSztJQUM3RyxJQUFJaUIsVUFBVXpDLDhEQUFXQSxDQUFDeUcsUUFBUTtRQUNoQ3BELFVBQVVzRTtJQUNaO0lBQ0EsSUFBSTFGLElBQXFDLEVBQUU7UUExWDdDLEtBMlh5QyxHQUFHcEMsaUVBQWNBLENBQUNxSCxlQUFlekUsV0FBVyxNQUFNLGlDQUFrQ2tCLFNBQVNOLFFBQVEsR0FBR00sU0FBU0wsTUFBTSxHQUFHSyxTQUFTUCxJQUFJLEdBQUcsUUFBUyxDQUFNO1FBM1hsTSxLQTRYeUMsR0FBR3ZELGlFQUFjQSxDQUFDNEMsV0FBVyxRQUFRQSxPQUFPLENBQUNBLFFBQVFqQixNQUFNLEdBQUcsRUFBRSxDQUFDMkYsS0FBSyxDQUFDVSxPQUFPLEtBQUtDLGFBQWFyRixPQUFPLENBQUNBLFFBQVFqQixNQUFNLEdBQUcsRUFBRSxDQUFDMkYsS0FBSyxDQUFDWSxTQUFTLEtBQUtELGFBQWFyRixPQUFPLENBQUNBLFFBQVFqQixNQUFNLEdBQUcsRUFBRSxDQUFDMkYsS0FBSyxDQUFDYSxJQUFJLEtBQUtGLFdBQVcscUNBQXNDbkUsU0FBU04sUUFBUSxHQUFHTSxTQUFTTCxNQUFNLEdBQUdLLFNBQVNQLElBQUksR0FBRyxPQUFRLDJGQUEyRix5REFBMkQsQ0FBTTtJQUMxZjtJQUNBLElBQUk2RSxrQkFBa0JDLGVBQWV6RixXQUFXQSxRQUFRMEYsR0FBRyxDQUFDQyxDQUFBQSxRQUFTbEgsT0FBT0MsTUFBTSxDQUFDLENBQUMsR0FBR2lILE9BQU87WUFDNUY5QixRQUFRcEYsT0FBT0MsTUFBTSxDQUFDLENBQUMsR0FBRzJGLGNBQWNzQixNQUFNOUIsTUFBTTtZQUNwRGpELFVBQVUzRCw0REFBU0EsQ0FBQztnQkFBQ3NIO2dCQUNyQiwyREFBMkQ7Z0JBQzNEOUQsVUFBVW1GLGNBQWMsR0FBR25GLFVBQVVtRixjQUFjLENBQUNELE1BQU0vRSxRQUFRLEVBQUVBLFFBQVEsR0FBRytFLE1BQU0vRSxRQUFRO2FBQUM7WUFDOUY0RCxjQUFjbUIsTUFBTW5CLFlBQVksS0FBSyxNQUFNRCxxQkFBcUJ0SCw0REFBU0EsQ0FBQztnQkFBQ3NIO2dCQUMzRSwyREFBMkQ7Z0JBQzNEOUQsVUFBVW1GLGNBQWMsR0FBR25GLFVBQVVtRixjQUFjLENBQUNELE1BQU1uQixZQUFZLEVBQUU1RCxRQUFRLEdBQUcrRSxNQUFNbkIsWUFBWTthQUFDO1FBQ3hHLEtBQUtKLGVBQWVELGlCQUFpQmpDO0lBRXJDLHVFQUF1RTtJQUN2RSw0RUFBNEU7SUFDNUUsNkRBQTZEO0lBQzdELElBQUkrQixlQUFldUIsaUJBQWlCO1FBQ2xDLE9BQU8sV0FBVyxHQUFFekksZ0RBQW1CLENBQUM4QyxnQkFBZ0I0RCxRQUFRLEVBQUU7WUFDaEVDLE9BQU87Z0JBQ0x4QyxVQUFVMUMsU0FBUztvQkFDakJvQyxVQUFVO29CQUNWQyxRQUFRO29CQUNSRixNQUFNO29CQUNOd0MsT0FBTztvQkFDUGxFLEtBQUs7Z0JBQ1AsR0FBR2lDO2dCQUNIRSxnQkFBZ0I1RCxxREFBTUEsQ0FBQ3FJLEdBQUc7WUFDNUI7UUFDRixHQUFHTDtJQUNMO0lBQ0EsT0FBT0E7QUFDVDtBQUNBLFNBQVNNO0lBQ1AsSUFBSUMsUUFBUUM7SUFDWixJQUFJQyxVQUFVckksdUVBQW9CQSxDQUFDbUksU0FBU0EsTUFBTUcsTUFBTSxHQUFHLE1BQU1ILE1BQU1JLFVBQVUsR0FBR0osaUJBQWlCSyxRQUFRTCxNQUFNRSxPQUFPLEdBQUc1RCxLQUFLQyxTQUFTLENBQUN5RDtJQUM1SSxJQUFJTSxRQUFRTixpQkFBaUJLLFFBQVFMLE1BQU1NLEtBQUssR0FBRztJQUNuRCxJQUFJQyxZQUFZO0lBQ2hCLElBQUlDLFlBQVk7UUFDZEMsU0FBUztRQUNUQyxpQkFBaUJIO0lBQ25CO0lBQ0EsSUFBSUksYUFBYTtRQUNmRixTQUFTO1FBQ1RDLGlCQUFpQkg7SUFDbkI7SUFDQSxJQUFJSyxVQUFVO0lBQ2QsSUFBSW5ILElBQXFDLEVBQUU7UUFDekNvSCxRQUFRYixLQUFLLENBQUMsd0RBQXdEQTtRQUN0RVksVUFBVSxXQUFXLEdBQUU1SixnREFBbUIsQ0FBQ0EsMkNBQWMsRUFBRSxNQUFNLFdBQVcsR0FBRUEsZ0RBQW1CLENBQUMsS0FBSyxNQUFNLDRDQUE0QyxXQUFXLEdBQUVBLGdEQUFtQixDQUFDLEtBQUssTUFBTSxnR0FBZ0csV0FBVyxHQUFFQSxnREFBbUIsQ0FBQyxRQUFRO1lBQzVVK0osT0FBT0o7UUFDVCxHQUFHLGtCQUFrQixPQUFPLEtBQUssV0FBVyxHQUFFM0osZ0RBQW1CLENBQUMsUUFBUTtZQUN4RStKLE9BQU9KO1FBQ1QsR0FBRyxpQkFBaUI7SUFDdEI7SUFDQSxPQUFPLFdBQVcsR0FBRTNKLGdEQUFtQixDQUFDQSwyQ0FBYyxFQUFFLE1BQU0sV0FBVyxHQUFFQSxnREFBbUIsQ0FBQyxNQUFNLE1BQU0sa0NBQWtDLFdBQVcsR0FBRUEsZ0RBQW1CLENBQUMsTUFBTTtRQUNsTCtKLE9BQU87WUFDTEMsV0FBVztRQUNiO0lBQ0YsR0FBR2QsVUFBVUksUUFBUSxXQUFXLEdBQUV0SixnREFBbUIsQ0FBQyxPQUFPO1FBQzNEK0osT0FBT1A7SUFDVCxHQUFHRixTQUFTLE1BQU1NO0FBQ3BCO0FBQ0EsTUFBTUssc0JBQXNCLFdBQVcsR0FBRWpLLGdEQUFtQixDQUFDK0ksdUJBQXVCO0FBQ3BGLE1BQU1tQiw0QkFBNEJsSyw0Q0FBZTtJQUMvQ21LLFlBQVlDLEtBQUssQ0FBRTtRQUNqQixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDaEUsS0FBSyxHQUFHO1lBQ1hqQyxVQUFVaUcsTUFBTWpHLFFBQVE7WUFDeEJrRyxjQUFjRCxNQUFNQyxZQUFZO1lBQ2hDckIsT0FBT29CLE1BQU1wQixLQUFLO1FBQ3BCO0lBQ0Y7SUFDQSxPQUFPc0IseUJBQXlCdEIsS0FBSyxFQUFFO1FBQ3JDLE9BQU87WUFDTEEsT0FBT0E7UUFDVDtJQUNGO0lBQ0EsT0FBT3VCLHlCQUF5QkgsS0FBSyxFQUFFaEUsS0FBSyxFQUFFO1FBQzVDLDRFQUE0RTtRQUM1RSx5RUFBeUU7UUFDekUsOEVBQThFO1FBQzlFLGlGQUFpRjtRQUNqRixFQUFFO1FBQ0YsMEVBQTBFO1FBQzFFLDJFQUEyRTtRQUMzRSxpREFBaUQ7UUFDakQsSUFBSUEsTUFBTWpDLFFBQVEsS0FBS2lHLE1BQU1qRyxRQUFRLElBQUlpQyxNQUFNaUUsWUFBWSxLQUFLLFVBQVVELE1BQU1DLFlBQVksS0FBSyxRQUFRO1lBQ3ZHLE9BQU87Z0JBQ0xyQixPQUFPb0IsTUFBTXBCLEtBQUs7Z0JBQ2xCN0UsVUFBVWlHLE1BQU1qRyxRQUFRO2dCQUN4QmtHLGNBQWNELE1BQU1DLFlBQVk7WUFDbEM7UUFDRjtRQUVBLDJFQUEyRTtRQUMzRSw0RUFBNEU7UUFDNUUsNEVBQTRFO1FBQzVFLHlCQUF5QjtRQUN6QixPQUFPO1lBQ0xyQixPQUFPb0IsTUFBTXBCLEtBQUssS0FBS1YsWUFBWThCLE1BQU1wQixLQUFLLEdBQUc1QyxNQUFNNEMsS0FBSztZQUM1RDdFLFVBQVVpQyxNQUFNakMsUUFBUTtZQUN4QmtHLGNBQWNELE1BQU1DLFlBQVksSUFBSWpFLE1BQU1pRSxZQUFZO1FBQ3hEO0lBQ0Y7SUFDQUcsa0JBQWtCeEIsS0FBSyxFQUFFeUIsU0FBUyxFQUFFO1FBQ2xDWixRQUFRYixLQUFLLENBQUMseURBQXlEQSxPQUFPeUI7SUFDaEY7SUFDQUMsU0FBUztRQUNQLE9BQU8sSUFBSSxDQUFDdEUsS0FBSyxDQUFDNEMsS0FBSyxLQUFLVixZQUFZLFdBQVcsR0FBRXRJLGdEQUFtQixDQUFDK0MsYUFBYTJELFFBQVEsRUFBRTtZQUM5RkMsT0FBTyxJQUFJLENBQUN5RCxLQUFLLENBQUNPLFlBQVk7UUFDaEMsR0FBRyxXQUFXLEdBQUUzSyxnREFBbUIsQ0FBQ21ELGtCQUFrQnVELFFBQVEsRUFBRTtZQUM5REMsT0FBTyxJQUFJLENBQUNQLEtBQUssQ0FBQzRDLEtBQUs7WUFDdkI0QixVQUFVLElBQUksQ0FBQ1IsS0FBSyxDQUFDUyxTQUFTO1FBQ2hDLE1BQU0sSUFBSSxDQUFDVCxLQUFLLENBQUNRLFFBQVE7SUFDM0I7QUFDRjtBQUNBLFNBQVNFLGNBQWNDLElBQUk7SUFDekIsSUFBSSxFQUNGSixZQUFZLEVBQ1ovQixLQUFLLEVBQ0xnQyxRQUFRLEVBQ1QsR0FBR0c7SUFDSixJQUFJN0Ysb0JBQW9CbEYsNkNBQWdCLENBQUN1QztJQUV6Qyw0RUFBNEU7SUFDNUUsd0JBQXdCO0lBQ3hCLElBQUkyQyxxQkFBcUJBLGtCQUFrQkwsTUFBTSxJQUFJSyxrQkFBa0I4RixhQUFhLElBQUtwQyxDQUFBQSxNQUFNakIsS0FBSyxDQUFDc0QsWUFBWSxJQUFJckMsTUFBTWpCLEtBQUssQ0FBQ3VELGFBQWEsR0FBRztRQUMvSWhHLGtCQUFrQjhGLGFBQWEsQ0FBQ0csMEJBQTBCLEdBQUd2QyxNQUFNakIsS0FBSyxDQUFDeUQsRUFBRTtJQUM3RTtJQUNBLE9BQU8sV0FBVyxHQUFFcEwsZ0RBQW1CLENBQUMrQyxhQUFhMkQsUUFBUSxFQUFFO1FBQzdEQyxPQUFPZ0U7SUFDVCxHQUFHQztBQUNMO0FBQ0EsU0FBU2xDLGVBQWV6RixPQUFPLEVBQUVvRSxhQUFhLEVBQUVELGVBQWUsRUFBRWpDLE1BQU07SUFDckUsSUFBSWtHO0lBQ0osSUFBSWhFLGtCQUFrQixLQUFLLEdBQUc7UUFDNUJBLGdCQUFnQixFQUFFO0lBQ3BCO0lBQ0EsSUFBSUQsb0JBQW9CLEtBQUssR0FBRztRQUM5QkEsa0JBQWtCO0lBQ3BCO0lBQ0EsSUFBSWpDLFdBQVcsS0FBSyxHQUFHO1FBQ3JCQSxTQUFTO0lBQ1g7SUFDQSxJQUFJbEMsV0FBVyxNQUFNO1FBQ25CLElBQUlxSTtRQUNKLElBQUksQ0FBQ0EsbUJBQW1CbEUsZUFBYyxLQUFNLFFBQVFrRSxpQkFBaUJDLE1BQU0sRUFBRTtZQUMzRSx3RUFBd0U7WUFDeEUsc0RBQXNEO1lBQ3REdEksVUFBVW1FLGdCQUFnQm5FLE9BQU87UUFDbkMsT0FBTztZQUNMLE9BQU87UUFDVDtJQUNGO0lBQ0EsSUFBSXdGLGtCQUFrQnhGO0lBRXRCLHFFQUFxRTtJQUNyRSxJQUFJc0ksU0FBUyxDQUFDRixvQkFBb0JqRSxlQUFjLEtBQU0sT0FBTyxLQUFLLElBQUlpRSxrQkFBa0JFLE1BQU07SUFDOUYsSUFBSUEsVUFBVSxNQUFNO1FBQ2xCLElBQUlDLGFBQWEvQyxnQkFBZ0JnRCxTQUFTLENBQUNDLENBQUFBLElBQUtBLEVBQUUvRCxLQUFLLENBQUN5RCxFQUFFLElBQUtHLENBQUFBLFVBQVUsT0FBTyxLQUFLLElBQUlBLE1BQU0sQ0FBQ0csRUFBRS9ELEtBQUssQ0FBQ3lELEVBQUUsQ0FBQztRQUMzRyxDQUFFSSxDQUFBQSxjQUFjLEtBQUsvSSxLQUFxQyxHQUFHeEMsbUVBQWdCQSxDQUFDLE9BQU8sOERBQThEeUIsT0FBT2lLLElBQUksQ0FBQ0osUUFBUUssSUFBSSxDQUFDLFFBQVEzTCxDQUF1QixHQUFHLEtBQUs7UUFDbk53SSxrQkFBa0JBLGdCQUFnQkwsS0FBSyxDQUFDLEdBQUd5RCxLQUFLQyxHQUFHLENBQUNyRCxnQkFBZ0J6RyxNQUFNLEVBQUV3SixhQUFhO0lBQzNGO0lBRUEsNEVBQTRFO0lBQzVFLHVFQUF1RTtJQUN2RSxJQUFJTyxpQkFBaUI7SUFDckIsSUFBSUMsZ0JBQWdCLENBQUM7SUFDckIsSUFBSTVFLG1CQUFtQmpDLFVBQVVBLE9BQU84RyxtQkFBbUIsRUFBRTtRQUMzRCxJQUFLLElBQUluSyxJQUFJLEdBQUdBLElBQUkyRyxnQkFBZ0J6RyxNQUFNLEVBQUVGLElBQUs7WUFDL0MsSUFBSThHLFFBQVFILGVBQWUsQ0FBQzNHLEVBQUU7WUFDOUIsbUVBQW1FO1lBQ25FLElBQUk4RyxNQUFNakIsS0FBSyxDQUFDdUUsZUFBZSxJQUFJdEQsTUFBTWpCLEtBQUssQ0FBQ3dFLHNCQUFzQixFQUFFO2dCQUNyRUgsZ0JBQWdCbEs7WUFDbEI7WUFDQSxJQUFJOEcsTUFBTWpCLEtBQUssQ0FBQ3lELEVBQUUsRUFBRTtnQkFDbEIsSUFBSSxFQUNGZ0IsVUFBVSxFQUNWYixNQUFNLEVBQ1AsR0FBR25FO2dCQUNKLElBQUlpRixtQkFBbUJ6RCxNQUFNakIsS0FBSyxDQUFDMkUsTUFBTSxJQUFJRixVQUFVLENBQUN4RCxNQUFNakIsS0FBSyxDQUFDeUQsRUFBRSxDQUFDLEtBQUs5QyxhQUFjLEVBQUNpRCxVQUFVQSxNQUFNLENBQUMzQyxNQUFNakIsS0FBSyxDQUFDeUQsRUFBRSxDQUFDLEtBQUs5QyxTQUFRO2dCQUN4SSxJQUFJTSxNQUFNakIsS0FBSyxDQUFDYSxJQUFJLElBQUk2RCxrQkFBa0I7b0JBQ3hDLGtFQUFrRTtvQkFDbEUsb0VBQW9FO29CQUNwRSxpRUFBaUU7b0JBQ2pFTixpQkFBaUI7b0JBQ2pCLElBQUlDLGlCQUFpQixHQUFHO3dCQUN0QnZELGtCQUFrQkEsZ0JBQWdCTCxLQUFLLENBQUMsR0FBRzRELGdCQUFnQjtvQkFDN0QsT0FBTzt3QkFDTHZELGtCQUFrQjs0QkFBQ0EsZUFBZSxDQUFDLEVBQUU7eUJBQUM7b0JBQ3hDO29CQUNBO2dCQUNGO1lBQ0Y7UUFDRjtJQUNGO0lBQ0EsT0FBT0EsZ0JBQWdCOEQsV0FBVyxDQUFDLENBQUN2SixRQUFRNEYsT0FBTzREO1FBQ2pELDRDQUE0QztRQUM1QyxJQUFJeEQ7UUFDSixJQUFJeUQsOEJBQThCO1FBQ2xDLElBQUl4QixlQUFlO1FBQ25CLElBQUlrQix5QkFBeUI7UUFDN0IsSUFBSS9FLGlCQUFpQjtZQUNuQjRCLFFBQVF1QyxVQUFVM0MsTUFBTWpCLEtBQUssQ0FBQ3lELEVBQUUsR0FBR0csTUFBTSxDQUFDM0MsTUFBTWpCLEtBQUssQ0FBQ3lELEVBQUUsQ0FBQyxHQUFHOUM7WUFDNUQyQyxlQUFlckMsTUFBTWpCLEtBQUssQ0FBQ3NELFlBQVksSUFBSWhCO1lBQzNDLElBQUk4QixnQkFBZ0I7Z0JBQ2xCLElBQUlDLGdCQUFnQixLQUFLUSxVQUFVLEdBQUc7b0JBQ3BDM0UsWUFBWSxrQkFBa0IsT0FBTztvQkFDckM0RSw4QkFBOEI7b0JBQzlCTix5QkFBeUI7Z0JBQzNCLE9BQU8sSUFBSUgsa0JBQWtCUSxPQUFPO29CQUNsQ0MsOEJBQThCO29CQUM5Qk4seUJBQXlCdkQsTUFBTWpCLEtBQUssQ0FBQ3dFLHNCQUFzQixJQUFJO2dCQUNqRTtZQUNGO1FBQ0Y7UUFDQSxJQUFJbEosVUFBVW9FLGNBQWNxRixNQUFNLENBQUNqRSxnQkFBZ0JMLEtBQUssQ0FBQyxHQUFHb0UsUUFBUTtRQUNwRSxJQUFJRyxjQUFjO1lBQ2hCLElBQUkvQjtZQUNKLElBQUk1QixPQUFPO2dCQUNUNEIsV0FBV0s7WUFDYixPQUFPLElBQUl3Qiw2QkFBNkI7Z0JBQ3RDN0IsV0FBV3VCO1lBQ2IsT0FBTyxJQUFJdkQsTUFBTWpCLEtBQUssQ0FBQ1ksU0FBUyxFQUFFO2dCQUNoQyxpRUFBaUU7Z0JBQ2pFLHlEQUF5RDtnQkFDekQsMkRBQTJEO2dCQUMzRCxvRUFBb0U7Z0JBQ3BFLHNFQUFzRTtnQkFDdEUsMkJBQTJCO2dCQUMzQnFDLFdBQVcsV0FBVyxHQUFFNUssZ0RBQW1CLENBQUM0SSxNQUFNakIsS0FBSyxDQUFDWSxTQUFTLEVBQUU7WUFDckUsT0FBTyxJQUFJSyxNQUFNakIsS0FBSyxDQUFDVSxPQUFPLEVBQUU7Z0JBQzlCdUMsV0FBV2hDLE1BQU1qQixLQUFLLENBQUNVLE9BQU87WUFDaEMsT0FBTztnQkFDTHVDLFdBQVc1SDtZQUNiO1lBQ0EsT0FBTyxXQUFXLEdBQUVoRCxnREFBbUIsQ0FBQzhLLGVBQWU7Z0JBQ3JEbEMsT0FBT0E7Z0JBQ1ArQixjQUFjO29CQUNaM0g7b0JBQ0FDO29CQUNBQyxhQUFha0UsbUJBQW1CO2dCQUNsQztnQkFDQXdELFVBQVVBO1lBQ1o7UUFDRjtRQUNBLDJFQUEyRTtRQUMzRSwyRUFBMkU7UUFDM0UseUNBQXlDO1FBQ3pDLE9BQU94RCxtQkFBb0J3QixDQUFBQSxNQUFNakIsS0FBSyxDQUFDdUQsYUFBYSxJQUFJdEMsTUFBTWpCLEtBQUssQ0FBQ3NELFlBQVksSUFBSXVCLFVBQVUsS0FBSyxXQUFXLEdBQUV4TSxnREFBbUIsQ0FBQ2tLLHFCQUFxQjtZQUN2Si9GLFVBQVVpRCxnQkFBZ0JqRCxRQUFRO1lBQ2xDa0csY0FBY2pELGdCQUFnQmlELFlBQVk7WUFDMUNRLFdBQVdJO1lBQ1hqQyxPQUFPQTtZQUNQNEIsVUFBVStCO1lBQ1ZoQyxjQUFjO2dCQUNaM0gsUUFBUTtnQkFDUkM7Z0JBQ0FDLGFBQWE7WUFDZjtRQUNGLEtBQUt5SjtJQUNQLEdBQUc7QUFDTDtBQUNBLElBQUlDLGlCQUFpQixXQUFXLEdBQUUsU0FBVUEsY0FBYztJQUN4REEsY0FBYyxDQUFDLGFBQWEsR0FBRztJQUMvQkEsY0FBYyxDQUFDLGlCQUFpQixHQUFHO0lBQ25DQSxjQUFjLENBQUMsb0JBQW9CLEdBQUc7SUFDdEMsT0FBT0E7QUFDVCxFQUFFQSxrQkFBa0IsQ0FBQztBQUNyQixJQUFJQyxzQkFBc0IsV0FBVyxHQUFFLFNBQVVBLG1CQUFtQjtJQUNsRUEsbUJBQW1CLENBQUMsYUFBYSxHQUFHO0lBQ3BDQSxtQkFBbUIsQ0FBQyxnQkFBZ0IsR0FBRztJQUN2Q0EsbUJBQW1CLENBQUMsZ0JBQWdCLEdBQUc7SUFDdkNBLG1CQUFtQixDQUFDLGdCQUFnQixHQUFHO0lBQ3ZDQSxtQkFBbUIsQ0FBQyxnQkFBZ0IsR0FBRztJQUN2Q0EsbUJBQW1CLENBQUMscUJBQXFCLEdBQUc7SUFDNUNBLG1CQUFtQixDQUFDLGFBQWEsR0FBRztJQUNwQ0EsbUJBQW1CLENBQUMsaUJBQWlCLEdBQUc7SUFDeENBLG1CQUFtQixDQUFDLG9CQUFvQixHQUFHO0lBQzNDQSxtQkFBbUIsQ0FBQyxhQUFhLEdBQUc7SUFDcEMsT0FBT0E7QUFDVCxFQUFFQSx1QkFBdUIsQ0FBQztBQUMxQixTQUFTQywwQkFBMEJDLFFBQVE7SUFDekMsT0FBT0EsV0FBVztBQUNwQjtBQUNBLFNBQVNDLHFCQUFxQkQsUUFBUTtJQUNwQyxJQUFJRSxNQUFNak4sNkNBQWdCLENBQUN1QztJQUMzQixDQUFDMEssTUFBTXhLLEtBQXFDLEdBQUd4QyxtRUFBZ0JBLENBQUMsT0FBTzZNLDBCQUEwQkMsYUFBYTlNLENBQXVCLEdBQUcsS0FBSztJQUM3SSxPQUFPZ047QUFDVDtBQUNBLFNBQVNDLG1CQUFtQkgsUUFBUTtJQUNsQyxJQUFJM0csUUFBUXBHLDZDQUFnQixDQUFDMkM7SUFDN0IsQ0FBQ3lELFFBQVEzRCxLQUFxQyxHQUFHeEMsbUVBQWdCQSxDQUFDLE9BQU82TSwwQkFBMEJDLGFBQWE5TSxDQUF1QixHQUFHLEtBQUs7SUFDL0ksT0FBT21HO0FBQ1Q7QUFDQSxTQUFTK0csZ0JBQWdCSixRQUFRO0lBQy9CLElBQUlwRixRQUFRM0gsNkNBQWdCLENBQUMrQztJQUM3QixDQUFDNEUsUUFBUWxGLEtBQXFDLEdBQUd4QyxtRUFBZ0JBLENBQUMsT0FBTzZNLDBCQUEwQkMsYUFBYTlNLENBQXVCLEdBQUcsS0FBSztJQUMvSSxPQUFPMEg7QUFDVDtBQUVBLGlEQUFpRDtBQUNqRCxTQUFTeUYsa0JBQWtCTCxRQUFRO0lBQ2pDLElBQUlwRixRQUFRd0YsZ0JBQWdCSjtJQUM1QixJQUFJTSxZQUFZMUYsTUFBTTFFLE9BQU8sQ0FBQzBFLE1BQU0xRSxPQUFPLENBQUNqQixNQUFNLEdBQUcsRUFBRTtJQUN2RCxDQUFDcUwsVUFBVTFGLEtBQUssQ0FBQ3lELEVBQUUsR0FBRzNJLEtBQXFDLEdBQUd4QyxtRUFBZ0JBLENBQUMsT0FBTzhNLFdBQVcsNERBQThEOU0sQ0FBdUIsR0FBRyxLQUFLO0lBQzlMLE9BQU9vTixVQUFVMUYsS0FBSyxDQUFDeUQsRUFBRTtBQUMzQjtBQUVBOztDQUVDLEdBQ0QsU0FBU2tDO0lBQ1AsT0FBT0Ysa0JBQWtCUCxvQkFBb0JVLFVBQVU7QUFDekQ7QUFFQTs7O0NBR0MsR0FDRCxTQUFTQztJQUNQLElBQUlwSCxRQUFROEcsbUJBQW1CTCxvQkFBb0JZLGFBQWE7SUFDaEUsT0FBT3JILE1BQU1zSCxVQUFVO0FBQ3pCO0FBRUE7OztDQUdDLEdBQ0QsU0FBU0M7SUFDUCxJQUFJekksb0JBQW9COEgscUJBQXFCSixlQUFlZ0IsY0FBYztJQUMxRSxJQUFJeEgsUUFBUThHLG1CQUFtQkwsb0JBQW9CZSxjQUFjO0lBQ2pFLE9BQU81TiwwQ0FBYSxDQUFDLElBQU87WUFDMUI2TixZQUFZM0ksa0JBQWtCNEksTUFBTSxDQUFDRCxVQUFVO1lBQy9DekgsT0FBT0EsTUFBTWlFLFlBQVk7UUFDM0IsSUFBSTtRQUFDbkYsa0JBQWtCNEksTUFBTSxDQUFDRCxVQUFVO1FBQUV6SCxNQUFNaUUsWUFBWTtLQUFDO0FBQy9EO0FBRUE7OztDQUdDLEdBQ0QsU0FBUzBEO0lBQ1AsSUFBSSxFQUNGOUssT0FBTyxFQUNQbUosVUFBVSxFQUNYLEdBQUdjLG1CQUFtQkwsb0JBQW9CbUIsVUFBVTtJQUNyRCxPQUFPaE8sMENBQWEsQ0FBQyxJQUFNaUQsUUFBUTBGLEdBQUcsQ0FBQytDLENBQUFBLElBQUtoTCxvRkFBaUNBLENBQUNnTCxHQUFHVSxjQUFjO1FBQUNuSjtRQUFTbUo7S0FBVztBQUN0SDtBQUVBOztDQUVDLEdBQ0QsU0FBUzZCO0lBQ1AsSUFBSTdILFFBQVE4RyxtQkFBbUJMLG9CQUFvQnFCLGFBQWE7SUFDaEUsSUFBSUMsVUFBVWYsa0JBQWtCUCxvQkFBb0JxQixhQUFhO0lBQ2pFLElBQUk5SCxNQUFNbUYsTUFBTSxJQUFJbkYsTUFBTW1GLE1BQU0sQ0FBQzRDLFFBQVEsSUFBSSxNQUFNO1FBQ2pEdEUsUUFBUWIsS0FBSyxDQUFDLDZEQUE2RG1GLFVBQVU7UUFDckYsT0FBTzdGO0lBQ1Q7SUFDQSxPQUFPbEMsTUFBTWdHLFVBQVUsQ0FBQytCLFFBQVE7QUFDbEM7QUFFQTs7Q0FFQyxHQUNELFNBQVNDLG1CQUFtQkQsT0FBTztJQUNqQyxJQUFJL0gsUUFBUThHLG1CQUFtQkwsb0JBQW9Cd0Isa0JBQWtCO0lBQ3JFLE9BQU9qSSxNQUFNZ0csVUFBVSxDQUFDK0IsUUFBUTtBQUNsQztBQUVBOztDQUVDLEdBQ0QsU0FBU0c7SUFDUCxJQUFJbEksUUFBUThHLG1CQUFtQkwsb0JBQW9CMEIsYUFBYTtJQUNoRSxJQUFJSixVQUFVZixrQkFBa0JQLG9CQUFvQnFCLGFBQWE7SUFDakUsT0FBTzlILE1BQU1vSSxVQUFVLEdBQUdwSSxNQUFNb0ksVUFBVSxDQUFDTCxRQUFRLEdBQUc3RjtBQUN4RDtBQUVBOzs7O0NBSUMsR0FDRCxTQUFTVztJQUNQLElBQUl3RjtJQUNKLElBQUl6RixRQUFRaEosNkNBQWdCLENBQUNtRDtJQUM3QixJQUFJaUQsUUFBUThHLG1CQUFtQkwsb0JBQW9CNkIsYUFBYTtJQUNoRSxJQUFJUCxVQUFVZixrQkFBa0JQLG9CQUFvQjZCLGFBQWE7SUFFakUsdUVBQXVFO0lBQ3ZFLHlCQUF5QjtJQUN6QixJQUFJMUYsVUFBVVYsV0FBVztRQUN2QixPQUFPVTtJQUNUO0lBRUEsdURBQXVEO0lBQ3ZELE9BQU8sQ0FBQ3lGLGdCQUFnQnJJLE1BQU1tRixNQUFNLEtBQUssT0FBTyxLQUFLLElBQUlrRCxhQUFhLENBQUNOLFFBQVE7QUFDakY7QUFFQTs7Q0FFQyxHQUNELFNBQVNRO0lBQ1AsSUFBSWhJLFFBQVEzRyw2Q0FBZ0IsQ0FBQzRDO0lBQzdCLE9BQU8rRCxTQUFTLE9BQU8sS0FBSyxJQUFJQSxNQUFNaUksS0FBSztBQUM3QztBQUVBOztDQUVDLEdBQ0QsU0FBU0M7SUFDUCxJQUFJbEksUUFBUTNHLDZDQUFnQixDQUFDNEM7SUFDN0IsT0FBTytELFNBQVMsT0FBTyxLQUFLLElBQUlBLE1BQU1tSSxNQUFNO0FBQzlDO0FBQ0EsSUFBSUMsWUFBWTtBQUVoQjs7Ozs7Q0FLQyxHQUNELFNBQVNDLFdBQVdDLFdBQVc7SUFDN0IsSUFBSSxFQUNGbkIsTUFBTSxFQUNOckssUUFBUSxFQUNULEdBQUd1SixxQkFBcUJKLGVBQWVzQyxVQUFVO0lBQ2xELElBQUk5SSxRQUFROEcsbUJBQW1CTCxvQkFBb0JxQyxVQUFVO0lBQzdELElBQUksQ0FBQ0MsWUFBWUMsY0FBYyxHQUFHcFAsMkNBQWMsQ0FBQztJQUNqRCxJQUFJc1Asa0JBQWtCdFAsOENBQWlCLENBQUN1UCxDQUFBQTtRQUN0QyxJQUFJLE9BQU9OLGdCQUFnQixZQUFZO1lBQ3JDLE9BQU8sQ0FBQyxDQUFDQTtRQUNYO1FBQ0EsSUFBSXhMLGFBQWEsS0FBSztZQUNwQixPQUFPd0wsWUFBWU07UUFDckI7UUFFQSx5RUFBeUU7UUFDekUsdUVBQXVFO1FBQ3ZFLGNBQWM7UUFDZCxJQUFJLEVBQ0ZDLGVBQWUsRUFDZkMsWUFBWSxFQUNaQyxhQUFhLEVBQ2QsR0FBR0g7UUFDSixPQUFPTixZQUFZO1lBQ2pCTyxpQkFBaUIvTixTQUFTLENBQUMsR0FBRytOLGlCQUFpQjtnQkFDN0MzTCxVQUFVbEQsZ0VBQWFBLENBQUM2TyxnQkFBZ0IzTCxRQUFRLEVBQUVKLGFBQWErTCxnQkFBZ0IzTCxRQUFRO1lBQ3pGO1lBQ0E0TCxjQUFjaE8sU0FBUyxDQUFDLEdBQUdnTyxjQUFjO2dCQUN2QzVMLFVBQVVsRCxnRUFBYUEsQ0FBQzhPLGFBQWE1TCxRQUFRLEVBQUVKLGFBQWFnTSxhQUFhNUwsUUFBUTtZQUNuRjtZQUNBNkw7UUFDRjtJQUNGLEdBQUc7UUFBQ2pNO1FBQVV3TDtLQUFZO0lBRTFCLDRFQUE0RTtJQUM1RSw4QkFBOEI7SUFDOUJqUCw0Q0FBZSxDQUFDO1FBQ2QsSUFBSWtDLE1BQU0wTixPQUFPLEVBQUViO1FBQ25CSyxjQUFjbE47UUFDZCxPQUFPLElBQU00TCxPQUFPK0IsYUFBYSxDQUFDM047SUFDcEMsR0FBRztRQUFDNEw7S0FBTztJQUVYLHdFQUF3RTtJQUN4RSx5RUFBeUU7SUFDekUsMEVBQTBFO0lBQzFFLHdEQUF3RDtJQUN4RDlOLDRDQUFlLENBQUM7UUFDZCxJQUFJbVAsZUFBZSxJQUFJO1lBQ3JCckIsT0FBT2dDLFVBQVUsQ0FBQ1gsWUFBWUc7UUFDaEM7SUFDRixHQUFHO1FBQUN4QjtRQUFRcUI7UUFBWUc7S0FBZ0I7SUFFeEMsNkVBQTZFO0lBQzdFLGlFQUFpRTtJQUNqRSxPQUFPSCxjQUFjL0ksTUFBTTJKLFFBQVEsQ0FBQ0MsR0FBRyxDQUFDYixjQUFjL0ksTUFBTTJKLFFBQVEsQ0FBQ0UsR0FBRyxDQUFDZCxjQUFjdk8sMkRBQVlBO0FBQ3JHO0FBRUE7OztDQUdDLEdBQ0QsU0FBU29FO0lBQ1AsSUFBSSxFQUNGOEksTUFBTSxFQUNQLEdBQUdkLHFCQUFxQkosZUFBZXNELGlCQUFpQjtJQUN6RCxJQUFJOUUsS0FBS2dDLGtCQUFrQlAsb0JBQW9CcUQsaUJBQWlCO0lBQ2hFLElBQUl6SyxZQUFZekYseUNBQVksQ0FBQztJQUM3QjBFLDBCQUEwQjtRQUN4QmUsVUFBVUUsT0FBTyxHQUFHO0lBQ3RCO0lBQ0EsSUFBSUMsV0FBVzVGLDhDQUFpQixDQUFDLFNBQVVxRCxFQUFFLEVBQUV5QyxPQUFPO1FBQ3BELElBQUlBLFlBQVksS0FBSyxHQUFHO1lBQ3RCQSxVQUFVLENBQUM7UUFDYjtRQTUyQkosS0E2MkJ5QyxHQUFHekYsaUVBQWNBLENBQUNvRixVQUFVRSxPQUFPLEVBQUVsQix5QkFBeUIsQ0FBTTtRQUV6Ryx3RUFBd0U7UUFDeEUsbUVBQW1FO1FBQ25FLElBQUksQ0FBQ2dCLFVBQVVFLE9BQU8sRUFBRTtRQUN4QixJQUFJLE9BQU90QyxPQUFPLFVBQVU7WUFDMUJ5SyxPQUFPbEksUUFBUSxDQUFDdkM7UUFDbEIsT0FBTztZQUNMeUssT0FBT2xJLFFBQVEsQ0FBQ3ZDLElBQUk1QixTQUFTO2dCQUMzQjBPLGFBQWEvRTtZQUNmLEdBQUd0RjtRQUNMO0lBQ0YsR0FBRztRQUFDZ0k7UUFBUTFDO0tBQUc7SUFDZixPQUFPeEY7QUFDVDtBQUNBLE1BQU13SyxnQkFBZ0IsQ0FBQztBQUN2QixTQUFTdkksWUFBWTNGLEdBQUcsRUFBRW1PLElBQUksRUFBRW5ILE9BQU87SUFDckMsSUFBSSxDQUFDbUgsUUFBUSxDQUFDRCxhQUFhLENBQUNsTyxJQUFJLEVBQUU7UUFDaENrTyxhQUFhLENBQUNsTyxJQUFJLEdBQUc7UUEvM0J6QixLQWc0QnlDLEdBQUc3QixpRUFBY0EsQ0FBQyxPQUFPNkksV0FBVyxDQUFNO0lBQ2pGO0FBQ0Y7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkEsR0FDQSxNQUFNb0gsbUJBQW1CO0FBQ3pCLE1BQU1DLHNCQUFzQnZRLGtDQUFLLENBQUNzUSxpQkFBaUI7QUFFbkQ7O0NBRUMsR0FDRCxTQUFTRSxlQUFlekYsSUFBSTtJQUMxQixJQUFJLEVBQ0YwRixlQUFlLEVBQ2YzQyxNQUFNLEVBQ04zSSxNQUFNLEVBQ1AsR0FBRzRGO0lBQ0osSUFBSSxDQUFDM0UsT0FBT3NLLGFBQWEsR0FBRzFRLDJDQUFjLENBQUM4TixPQUFPMUgsS0FBSztJQUN2RCxJQUFJLEVBQ0Z1SyxrQkFBa0IsRUFDbkIsR0FBR3hMLFVBQVUsQ0FBQztJQUNmLElBQUl5TCxXQUFXNVEsOENBQWlCLENBQUM2USxDQUFBQTtRQUMvQixJQUFJRixzQkFBc0JKLHFCQUFxQjtZQUM3Q0Esb0JBQW9CLElBQU1HLGFBQWFHO1FBQ3pDLE9BQU87WUFDTEgsYUFBYUc7UUFDZjtJQUNGLEdBQUc7UUFBQ0g7UUFBY0M7S0FBbUI7SUFFckMsd0VBQXdFO0lBQ3hFLDRFQUE0RTtJQUM1RTNRLGtEQUFxQixDQUFDLElBQU04TixPQUFPZ0QsU0FBUyxDQUFDRixXQUFXO1FBQUM5QztRQUFROEM7S0FBUztJQUMxRTVRLDRDQUFlLENBQUM7UUFwN0JsQixLQXE3QnlDLEdBQUdLLGlFQUFjQSxDQUFDb1EsbUJBQW1CLFFBQVEsQ0FBQzNDLE9BQU8zSSxNQUFNLENBQUM4RyxtQkFBbUIsRUFBRSxpRUFBaUUsc0VBQXNFLENBQU07SUFDblEsc0NBQXNDO0lBQ3RDLHVEQUF1RDtJQUN6RCxHQUFHLEVBQUU7SUFDTCxJQUFJdkksWUFBWTFELDBDQUFhLENBQUM7UUFDNUIsT0FBTztZQUNMaUUsWUFBWTZKLE9BQU83SixVQUFVO1lBQzdCNEUsZ0JBQWdCaUYsT0FBT2pGLGNBQWM7WUFDckM5QyxJQUFJZ0wsQ0FBQUEsSUFBS2pELE9BQU9sSSxRQUFRLENBQUNtTDtZQUN6QjVLLE1BQU0sQ0FBQzlDLElBQUkrQyxPQUFPNEssT0FBU2xELE9BQU9sSSxRQUFRLENBQUN2QyxJQUFJO29CQUM3QytDO29CQUNBNkssb0JBQW9CRCxRQUFRLE9BQU8sS0FBSyxJQUFJQSxLQUFLQyxrQkFBa0I7Z0JBQ3JFO1lBQ0EvSyxTQUFTLENBQUM3QyxJQUFJK0MsT0FBTzRLLE9BQVNsRCxPQUFPbEksUUFBUSxDQUFDdkMsSUFBSTtvQkFDaEQ2QyxTQUFTO29CQUNURTtvQkFDQTZLLG9CQUFvQkQsUUFBUSxPQUFPLEtBQUssSUFBSUEsS0FBS0Msa0JBQWtCO2dCQUNyRTtRQUNGO0lBQ0YsR0FBRztRQUFDbkQ7S0FBTztJQUNYLElBQUlySyxXQUFXcUssT0FBT3JLLFFBQVEsSUFBSTtJQUNsQyxJQUFJeUIsb0JBQW9CbEYsMENBQWEsQ0FBQyxJQUFPO1lBQzNDOE47WUFDQXBLO1lBQ0FtQixRQUFRO1lBQ1JwQjtRQUNGLElBQUk7UUFBQ3FLO1FBQVFwSztRQUFXRDtLQUFTO0lBRWpDLCtFQUErRTtJQUMvRSw2RUFBNkU7SUFDN0UsaUZBQWlGO0lBQ2pGLDhFQUE4RTtJQUM5RSxxRUFBcUU7SUFDckUsaUNBQWlDO0lBQ2pDLE9BQU8sV0FBVyxHQUFFekQsZ0RBQW1CLENBQUNBLDJDQUFjLEVBQUUsTUFBTSxXQUFXLEdBQUVBLGdEQUFtQixDQUFDdUMsa0JBQWtCbUUsUUFBUSxFQUFFO1FBQ3pIQyxPQUFPekI7SUFDVCxHQUFHLFdBQVcsR0FBRWxGLGdEQUFtQixDQUFDMkMsdUJBQXVCK0QsUUFBUSxFQUFFO1FBQ25FQyxPQUFPUDtJQUNULEdBQUcsV0FBVyxHQUFFcEcsZ0RBQW1CLENBQUNrUixRQUFRO1FBQzFDek4sVUFBVUE7UUFDVlUsVUFBVWlDLE1BQU1qQyxRQUFRO1FBQ3hCRSxnQkFBZ0IrQixNQUFNc0osYUFBYTtRQUNuQ2hNLFdBQVdBO1FBQ1h5QixRQUFRO1lBQ05LLHNCQUFzQnNJLE9BQU8zSSxNQUFNLENBQUNLLG9CQUFvQjtRQUMxRDtJQUNGLEdBQUdZLE1BQU0rSyxXQUFXLElBQUlyRCxPQUFPM0ksTUFBTSxDQUFDOEcsbUJBQW1CLEdBQUcsV0FBVyxHQUFFak0sZ0RBQW1CLENBQUNvUixZQUFZO1FBQ3ZHbkssUUFBUTZHLE9BQU83RyxNQUFNO1FBQ3JCOUIsUUFBUTJJLE9BQU8zSSxNQUFNO1FBQ3JCaUIsT0FBT0E7SUFDVCxLQUFLcUssb0JBQW9CO0FBQzNCO0FBQ0EsU0FBU1csV0FBV0MsS0FBSztJQUN2QixJQUFJLEVBQ0ZwSyxNQUFNLEVBQ045QixNQUFNLEVBQ05pQixLQUFLLEVBQ04sR0FBR2lMO0lBQ0osT0FBT2xLLGNBQWNGLFFBQVFxQixXQUFXbEMsT0FBT2pCO0FBQ2pEO0FBQ0E7Ozs7Q0FJQyxHQUNELFNBQVNtTSxhQUFhQyxLQUFLO0lBQ3pCLElBQUksRUFDRjlOLFFBQVEsRUFDUm1ILFFBQVEsRUFDUjRHLGNBQWMsRUFDZEMsWUFBWSxFQUNadE0sTUFBTSxFQUNQLEdBQUdvTTtJQUNKLElBQUlHLGFBQWExUix5Q0FBWTtJQUM3QixJQUFJMFIsV0FBVy9MLE9BQU8sSUFBSSxNQUFNO1FBQzlCK0wsV0FBVy9MLE9BQU8sR0FBRzdFLHNFQUFtQkEsQ0FBQztZQUN2QzBRO1lBQ0FDO1lBQ0FFLFVBQVU7UUFDWjtJQUNGO0lBQ0EsSUFBSUMsVUFBVUYsV0FBVy9MLE9BQU87SUFDaEMsSUFBSSxDQUFDUyxPQUFPc0ssYUFBYSxHQUFHMVEsMkNBQWMsQ0FBQztRQUN6QzZSLFFBQVFELFFBQVFDLE1BQU07UUFDdEIxTixVQUFVeU4sUUFBUXpOLFFBQVE7SUFDNUI7SUFDQSxJQUFJLEVBQ0Z3TSxrQkFBa0IsRUFDbkIsR0FBR3hMLFVBQVUsQ0FBQztJQUNmLElBQUl5TCxXQUFXNVEsOENBQWlCLENBQUM2USxDQUFBQTtRQUMvQkYsc0JBQXNCSixzQkFBc0JBLG9CQUFvQixJQUFNRyxhQUFhRyxhQUFhSCxhQUFhRztJQUMvRyxHQUFHO1FBQUNIO1FBQWNDO0tBQW1CO0lBQ3JDM1Esa0RBQXFCLENBQUMsSUFBTTRSLFFBQVFFLE1BQU0sQ0FBQ2xCLFdBQVc7UUFBQ2dCO1FBQVNoQjtLQUFTO0lBQ3pFLE9BQU8sV0FBVyxHQUFFNVEsZ0RBQW1CLENBQUNrUixRQUFRO1FBQzlDek4sVUFBVUE7UUFDVm1ILFVBQVVBO1FBQ1Z6RyxVQUFVaUMsTUFBTWpDLFFBQVE7UUFDeEJFLGdCQUFnQitCLE1BQU15TCxNQUFNO1FBQzVCbk8sV0FBV2tPO1FBQ1h6TSxRQUFRQTtJQUNWO0FBQ0Y7QUFDQTs7Ozs7Ozs7Q0FRQyxHQUNELFNBQVM0TSxTQUFTQyxLQUFLO0lBQ3JCLElBQUksRUFDRjNPLEVBQUUsRUFDRjZDLE9BQU8sRUFDUEUsS0FBSyxFQUNMN0MsUUFBUSxFQUNULEdBQUd5TztJQUNKLENBQUN4Tyx1QkFBdUJmLEtBQXFDLEdBQUd4QyxtRUFBZ0JBLENBQUMsT0FDakYsb0VBQW9FO0lBQ3BFLHlFQUF5RUEsQ0FBdUIsR0FBRyxLQUFLO0lBQ3hHLElBQUksRUFDRmtGLE1BQU0sRUFDTk4sUUFBUUQsUUFBUSxFQUNqQixHQUFHNUUsNkNBQWdCLENBQUM2QztJQWpqQ3ZCLEtBa2pDdUMsR0FBR3hDLGlFQUFjQSxDQUFDLENBQUN1RSxVQUFVLDRFQUE0RSwyRUFBMkUsOEVBQThFLENBQU07SUFDN1MsSUFBSSxFQUNGM0IsT0FBTyxFQUNSLEdBQUdqRCw2Q0FBZ0IsQ0FBQytDO0lBQ3JCLElBQUksRUFDRmMsVUFBVXVCLGdCQUFnQixFQUMzQixHQUFHbEI7SUFDSixJQUFJMEIsV0FBV2I7SUFFZiwyRUFBMkU7SUFDM0UsNkNBQTZDO0lBQzdDLElBQUlpQixPQUFPMUYsNERBQVNBLENBQUMrQyxJQUFJakQsNkVBQTBCQSxDQUFDNkMsU0FBU2tDLE9BQU9LLG9CQUFvQixHQUFHSixrQkFBa0I3QixhQUFhO0lBQzFILElBQUkwTyxXQUFXM00sS0FBS0MsU0FBUyxDQUFDUztJQUM5QmhHLDRDQUFlLENBQUMsSUFBTTRGLFNBQVNOLEtBQUtXLEtBQUssQ0FBQ2dNLFdBQVc7WUFDbkQvTDtZQUNBRTtZQUNBN0M7UUFDRixJQUFJO1FBQUNxQztRQUFVcU07UUFBVTFPO1FBQVUyQztRQUFTRTtLQUFNO0lBQ2xELE9BQU87QUFDVDtBQUNBOzs7O0NBSUMsR0FDRCxTQUFTOEwsT0FBTzlILEtBQUs7SUFDbkIsT0FBTzdELFVBQVU2RCxNQUFNNUQsT0FBTztBQUNoQztBQUNBOzs7O0NBSUMsR0FDRCxTQUFTMkwsTUFBTUMsTUFBTTtJQW5sQ3JCLEtBb2xDdUMsR0FBR25TLG1FQUFnQkEsQ0FBQyxPQUFPLHlFQUF5RSxzRUFBc0VBLENBQXVCO0FBQ3hPO0FBQ0E7Ozs7Ozs7O0NBUUMsR0FDRCxTQUFTaVIsT0FBT21CLEtBQUs7SUFDbkIsSUFBSSxFQUNGNU8sVUFBVTZPLGVBQWUsR0FBRyxFQUM1QjFILFdBQVcsSUFBSSxFQUNmekcsVUFBVW9PLFlBQVksRUFDdEJsTyxpQkFBaUI1RCxxREFBTUEsQ0FBQ3FJLEdBQUcsRUFDM0JwRixTQUFTLEVBQ1RtQixRQUFRMk4sYUFBYSxLQUFLLEVBQzFCck4sTUFBTSxFQUNQLEdBQUdrTjtJQUNKLENBQUMsQ0FBQzdPLHVCQUF1QmYsS0FBcUMsR0FBR3hDLG1FQUFnQkEsQ0FBQyxPQUFPLDBEQUEwRCx1REFBdURBLENBQXVCLEdBQUcsS0FBSztJQUV6Tyx3RUFBd0U7SUFDeEUseURBQXlEO0lBQ3pELElBQUl3RCxXQUFXNk8sYUFBYXBNLE9BQU8sQ0FBQyxRQUFRO0lBQzVDLElBQUl1TSxvQkFBb0J6UywwQ0FBYSxDQUFDLElBQU87WUFDM0N5RDtZQUNBQztZQUNBbUIsUUFBUTJOO1lBQ1JyTixRQUFRMUQsU0FBUztnQkFDZitELHNCQUFzQjtZQUN4QixHQUFHTDtRQUNMLElBQUk7UUFBQzFCO1FBQVUwQjtRQUFRekI7UUFBVzhPO0tBQVc7SUFDN0MsSUFBSSxPQUFPRCxpQkFBaUIsVUFBVTtRQUNwQ0EsZUFBZWhTLDREQUFTQSxDQUFDZ1M7SUFDM0I7SUFDQSxJQUFJLEVBQ0YxTyxXQUFXLEdBQUcsRUFDZEMsU0FBUyxFQUFFLEVBQ1hGLE9BQU8sRUFBRSxFQUNUd0MsUUFBUSxJQUFJLEVBQ1psRSxNQUFNLFNBQVMsRUFDaEIsR0FBR3FRO0lBQ0osSUFBSUcsa0JBQWtCMVMsMENBQWEsQ0FBQztRQUNsQyxJQUFJMlMsbUJBQW1CaFMsZ0VBQWFBLENBQUNrRCxVQUFVSjtRQUMvQyxJQUFJa1Asb0JBQW9CLE1BQU07WUFDNUIsT0FBTztRQUNUO1FBQ0EsT0FBTztZQUNMeE8sVUFBVTtnQkFDUk4sVUFBVThPO2dCQUNWN087Z0JBQ0FGO2dCQUNBd0M7Z0JBQ0FsRTtZQUNGO1lBQ0FtQztRQUNGO0lBQ0YsR0FBRztRQUFDWjtRQUFVSTtRQUFVQztRQUFRRjtRQUFNd0M7UUFBT2xFO1FBQUttQztLQUFlO0lBL29DbkUsS0FncEN1QyxHQUFHaEUsaUVBQWNBLENBQUNxUyxtQkFBbUIsTUFBTSx1QkFBd0JqUCxXQUFXLHFDQUF1QyxPQUFPSSxXQUFXQyxTQUFTRixPQUFPLHVDQUF1QyxJQUFLLHNEQUFzRCxDQUFNO0lBQ3BTLElBQUk4TyxtQkFBbUIsTUFBTTtRQUMzQixPQUFPO0lBQ1Q7SUFDQSxPQUFPLFdBQVcsR0FBRTFTLGdEQUFtQixDQUFDNkMsa0JBQWtCNkQsUUFBUSxFQUFFO1FBQ2xFQyxPQUFPOEw7SUFDVCxHQUFHLFdBQVcsR0FBRXpTLGdEQUFtQixDQUFDOEMsZ0JBQWdCNEQsUUFBUSxFQUFFO1FBQzVEa0UsVUFBVUE7UUFDVmpFLE9BQU8rTDtJQUNUO0FBQ0Y7QUFDQTs7Ozs7Q0FLQyxHQUNELFNBQVNFLE9BQU9DLEtBQUs7SUFDbkIsSUFBSSxFQUNGakksUUFBUSxFQUNSekcsUUFBUSxFQUNULEdBQUcwTztJQUNKLE9BQU83TCxVQUFVOEwseUJBQXlCbEksV0FBV3pHO0FBQ3ZEO0FBQ0E7OztDQUdDLEdBQ0QsU0FBUzRPLE1BQU1DLEtBQUs7SUFDbEIsSUFBSSxFQUNGcEksUUFBUSxFQUNSSyxZQUFZLEVBQ1pnSSxPQUFPLEVBQ1IsR0FBR0Q7SUFDSixPQUFPLFdBQVcsR0FBRWhULGdEQUFtQixDQUFDa1Qsb0JBQW9CO1FBQzFERCxTQUFTQTtRQUNUaEksY0FBY0E7SUFDaEIsR0FBRyxXQUFXLEdBQUVqTCxnREFBbUIsQ0FBQ21ULGNBQWMsTUFBTXZJO0FBQzFEO0FBQ0EsSUFBSXdJLG9CQUFvQixXQUFXLEdBQUUsU0FBVUEsaUJBQWlCO0lBQzlEQSxpQkFBaUIsQ0FBQ0EsaUJBQWlCLENBQUMsVUFBVSxHQUFHLEVBQUUsR0FBRztJQUN0REEsaUJBQWlCLENBQUNBLGlCQUFpQixDQUFDLFVBQVUsR0FBRyxFQUFFLEdBQUc7SUFDdERBLGlCQUFpQixDQUFDQSxpQkFBaUIsQ0FBQyxRQUFRLEdBQUcsRUFBRSxHQUFHO0lBQ3BELE9BQU9BO0FBQ1QsRUFBRUEscUJBQXFCLENBQUM7QUFDeEIsTUFBTUMsc0JBQXNCLElBQUlDLFFBQVEsS0FBTztBQUMvQyxNQUFNSiwyQkFBMkJsVCw0Q0FBZTtJQUM5Q21LLFlBQVlDLEtBQUssQ0FBRTtRQUNqQixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDaEUsS0FBSyxHQUFHO1lBQ1g0QyxPQUFPO1FBQ1Q7SUFDRjtJQUNBLE9BQU9zQix5QkFBeUJ0QixLQUFLLEVBQUU7UUFDckMsT0FBTztZQUNMQTtRQUNGO0lBQ0Y7SUFDQXdCLGtCQUFrQnhCLEtBQUssRUFBRXlCLFNBQVMsRUFBRTtRQUNsQ1osUUFBUWIsS0FBSyxDQUFDLG9EQUFvREEsT0FBT3lCO0lBQzNFO0lBQ0FDLFNBQVM7UUFDUCxJQUFJLEVBQ0ZFLFFBQVEsRUFDUkssWUFBWSxFQUNaZ0ksT0FBTyxFQUNSLEdBQUcsSUFBSSxDQUFDN0ksS0FBSztRQUNkLElBQUltSixVQUFVO1FBQ2QsSUFBSXBLLFNBQVNpSyxrQkFBa0JJLE9BQU87UUFDdEMsSUFBSSxDQUFFUCxDQUFBQSxtQkFBbUJLLE9BQU0sR0FBSTtZQUNqQyx1REFBdUQ7WUFDdkRuSyxTQUFTaUssa0JBQWtCSyxPQUFPO1lBQ2xDRixVQUFVRCxRQUFRTCxPQUFPO1lBQ3pCdlIsT0FBT2dTLGNBQWMsQ0FBQ0gsU0FBUyxZQUFZO2dCQUN6Q3RELEtBQUssSUFBTTtZQUNiO1lBQ0F2TyxPQUFPZ1MsY0FBYyxDQUFDSCxTQUFTLFNBQVM7Z0JBQ3RDdEQsS0FBSyxJQUFNZ0Q7WUFDYjtRQUNGLE9BQU8sSUFBSSxJQUFJLENBQUM3TSxLQUFLLENBQUM0QyxLQUFLLEVBQUU7WUFDM0IsMERBQTBEO1lBQzFERyxTQUFTaUssa0JBQWtCcEssS0FBSztZQUNoQyxJQUFJMkssY0FBYyxJQUFJLENBQUN2TixLQUFLLENBQUM0QyxLQUFLO1lBQ2xDdUssVUFBVUQsUUFBUU0sTUFBTSxHQUFHQyxLQUFLLENBQUMsS0FBTyxJQUFJLHFDQUFxQztZQUNqRm5TLE9BQU9nUyxjQUFjLENBQUNILFNBQVMsWUFBWTtnQkFDekN0RCxLQUFLLElBQU07WUFDYjtZQUNBdk8sT0FBT2dTLGNBQWMsQ0FBQ0gsU0FBUyxVQUFVO2dCQUN2Q3RELEtBQUssSUFBTTBEO1lBQ2I7UUFDRixPQUFPLElBQUlWLFFBQVFhLFFBQVEsRUFBRTtZQUMzQiwyQ0FBMkM7WUFDM0NQLFVBQVVOO1lBQ1Y5SixTQUFTb0ssUUFBUXpFLE1BQU0sS0FBS3hHLFlBQVk4SyxrQkFBa0JwSyxLQUFLLEdBQUd1SyxRQUFRM0UsS0FBSyxLQUFLdEcsWUFBWThLLGtCQUFrQkssT0FBTyxHQUFHTCxrQkFBa0JJLE9BQU87UUFDdkosT0FBTztZQUNMLHFDQUFxQztZQUNyQ3JLLFNBQVNpSyxrQkFBa0JJLE9BQU87WUFDbEM5UixPQUFPZ1MsY0FBYyxDQUFDVCxTQUFTLFlBQVk7Z0JBQ3pDaEQsS0FBSyxJQUFNO1lBQ2I7WUFDQXNELFVBQVVOLFFBQVFjLElBQUksQ0FBQ0MsQ0FBQUEsT0FBUXRTLE9BQU9nUyxjQUFjLENBQUNULFNBQVMsU0FBUztvQkFDckVoRCxLQUFLLElBQU0rRDtnQkFDYixJQUFJaEwsQ0FBQUEsUUFBU3RILE9BQU9nUyxjQUFjLENBQUNULFNBQVMsVUFBVTtvQkFDcERoRCxLQUFLLElBQU1qSDtnQkFDYjtRQUNGO1FBQ0EsSUFBSUcsV0FBV2lLLGtCQUFrQnBLLEtBQUssSUFBSXVLLFFBQVF6RSxNQUFNLFlBQVkvTixtRUFBb0JBLEVBQUU7WUFDeEYscURBQXFEO1lBQ3JELE1BQU1zUztRQUNSO1FBQ0EsSUFBSWxLLFdBQVdpSyxrQkFBa0JwSyxLQUFLLElBQUksQ0FBQ2lDLGNBQWM7WUFDdkQsbUVBQW1FO1lBQ25FLE1BQU1zSSxRQUFRekUsTUFBTTtRQUN0QjtRQUNBLElBQUkzRixXQUFXaUssa0JBQWtCcEssS0FBSyxFQUFFO1lBQ3RDLDhCQUE4QjtZQUM5QixPQUFPLFdBQVcsR0FBRWhKLGdEQUFtQixDQUFDNEMsYUFBYThELFFBQVEsRUFBRTtnQkFDN0RDLE9BQU80TTtnQkFDUDNJLFVBQVVLO1lBQ1o7UUFDRjtRQUNBLElBQUk5QixXQUFXaUssa0JBQWtCSyxPQUFPLEVBQUU7WUFDeEMsc0NBQXNDO1lBQ3RDLE9BQU8sV0FBVyxHQUFFelQsZ0RBQW1CLENBQUM0QyxhQUFhOEQsUUFBUSxFQUFFO2dCQUM3REMsT0FBTzRNO2dCQUNQM0ksVUFBVUE7WUFDWjtRQUNGO1FBRUEsaUNBQWlDO1FBQ2pDLE1BQU0ySTtJQUNSO0FBQ0Y7QUFFQTs7O0NBR0MsR0FDRCxTQUFTSixhQUFhYyxLQUFLO0lBQ3pCLElBQUksRUFDRnJKLFFBQVEsRUFDVCxHQUFHcUo7SUFDSixJQUFJRCxPQUFPckY7SUFDWCxJQUFJdUYsV0FBVyxPQUFPdEosYUFBYSxhQUFhQSxTQUFTb0osUUFBUXBKO0lBQ2pFLE9BQU8sV0FBVyxHQUFFNUssZ0RBQW1CLENBQUNBLDJDQUFjLEVBQUUsTUFBTWtVO0FBQ2hFO0FBRUEsK0VBQStFO0FBQy9FLFFBQVE7QUFDUiwrRUFBK0U7QUFFL0U7Ozs7OztDQU1DLEdBQ0QsU0FBU3BCLHlCQUF5QmxJLFFBQVEsRUFBRWhELFVBQVU7SUFDcEQsSUFBSUEsZUFBZSxLQUFLLEdBQUc7UUFDekJBLGFBQWEsRUFBRTtJQUNqQjtJQUNBLElBQUlYLFNBQVMsRUFBRTtJQUNmakgsMkNBQWMsQ0FBQ29VLE9BQU8sQ0FBQ3hKLFVBQVUsQ0FBQ3ZDLFNBQVNtRTtRQUN6QyxJQUFJLENBQUUsV0FBVyxHQUFFeE0saURBQW9CLENBQUNxSSxVQUFVO1lBQ2hELGdFQUFnRTtZQUNoRSxzQ0FBc0M7WUFDdEM7UUFDRjtRQUNBLElBQUlpTSxXQUFXO2VBQUkxTTtZQUFZNEU7U0FBTTtRQUNyQyxJQUFJbkUsUUFBUWtNLElBQUksS0FBS3ZVLDJDQUFjLEVBQUU7WUFDbkMseURBQXlEO1lBQ3pEaUgsT0FBT2QsSUFBSSxDQUFDN0QsS0FBSyxDQUFDMkUsUUFBUTZMLHlCQUF5QnpLLFFBQVErQixLQUFLLENBQUNRLFFBQVEsRUFBRTBKO1lBQzNFO1FBQ0Y7UUFDQSxDQUFFak0sQ0FBQUEsUUFBUWtNLElBQUksS0FBS3BDLEtBQUksSUFBSzFQLEtBQXFDLEdBQUd4QyxtRUFBZ0JBLENBQUMsT0FBTyxNQUFPLFFBQU9vSSxRQUFRa00sSUFBSSxLQUFLLFdBQVdsTSxRQUFRa00sSUFBSSxHQUFHbE0sUUFBUWtNLElBQUksQ0FBQ0MsSUFBSSxJQUFJLDRHQUE0R3ZVLENBQXVCLEdBQUcsS0FBSztRQUNyVCxDQUFFLEVBQUNvSSxRQUFRK0IsS0FBSyxDQUFDb0MsS0FBSyxJQUFJLENBQUNuRSxRQUFRK0IsS0FBSyxDQUFDUSxRQUFRLElBQUluSSxLQUFxQyxHQUFHeEMsbUVBQWdCQSxDQUFDLE9BQU8sOENBQThDQSxDQUF1QixHQUFHLEtBQUs7UUFDbE0sSUFBSTBILFFBQVE7WUFDVnlELElBQUkvQyxRQUFRK0IsS0FBSyxDQUFDZ0IsRUFBRSxJQUFJa0osU0FBUzFJLElBQUksQ0FBQztZQUN0QzZJLGVBQWVwTSxRQUFRK0IsS0FBSyxDQUFDcUssYUFBYTtZQUMxQ3BNLFNBQVNBLFFBQVErQixLQUFLLENBQUMvQixPQUFPO1lBQzlCRSxXQUFXRixRQUFRK0IsS0FBSyxDQUFDN0IsU0FBUztZQUNsQ2lFLE9BQU9uRSxRQUFRK0IsS0FBSyxDQUFDb0MsS0FBSztZQUMxQnhHLE1BQU1xQyxRQUFRK0IsS0FBSyxDQUFDcEUsSUFBSTtZQUN4QnNHLFFBQVFqRSxRQUFRK0IsS0FBSyxDQUFDa0MsTUFBTTtZQUM1QnVGLFFBQVF4SixRQUFRK0IsS0FBSyxDQUFDeUgsTUFBTTtZQUM1QjVHLGNBQWM1QyxRQUFRK0IsS0FBSyxDQUFDYSxZQUFZO1lBQ3hDQyxlQUFlN0MsUUFBUStCLEtBQUssQ0FBQ2MsYUFBYTtZQUMxQ3dKLGtCQUFrQnJNLFFBQVErQixLQUFLLENBQUNjLGFBQWEsSUFBSSxRQUFRN0MsUUFBUStCLEtBQUssQ0FBQ2EsWUFBWSxJQUFJO1lBQ3ZGMEosa0JBQWtCdE0sUUFBUStCLEtBQUssQ0FBQ3VLLGdCQUFnQjtZQUNoREMsUUFBUXZNLFFBQVErQixLQUFLLENBQUN3SyxNQUFNO1lBQzVCcE0sTUFBTUgsUUFBUStCLEtBQUssQ0FBQzVCLElBQUk7UUFDMUI7UUFDQSxJQUFJSCxRQUFRK0IsS0FBSyxDQUFDUSxRQUFRLEVBQUU7WUFDMUJqRCxNQUFNaUQsUUFBUSxHQUFHa0kseUJBQXlCekssUUFBUStCLEtBQUssQ0FBQ1EsUUFBUSxFQUFFMEo7UUFDcEU7UUFDQXJOLE9BQU9kLElBQUksQ0FBQ3dCO0lBQ2Q7SUFDQSxPQUFPVjtBQUNUO0FBRUE7O0NBRUMsR0FDRCxTQUFTNE4sY0FBYzVSLE9BQU87SUFDNUIsT0FBT3lGLGVBQWV6RjtBQUN4QjtBQUVBLFNBQVM2UixtQkFBbUJuTixLQUFLO0lBQy9CLElBQUlvTixVQUFVO1FBQ1oscUVBQXFFO1FBQ3JFLG9EQUFvRDtRQUNwREwsa0JBQWtCL00sTUFBTXVELGFBQWEsSUFBSSxRQUFRdkQsTUFBTXNELFlBQVksSUFBSTtJQUN6RTtJQUNBLElBQUl0RCxNQUFNWSxTQUFTLEVBQUU7UUFDbkIsSUFBSTlGLElBQXFDLEVBQUU7WUFDekMsSUFBSWtGLE1BQU1VLE9BQU8sRUFBRTtnQkF4MkN6QixLQXkyQzZDLEdBQUdoSSxpRUFBY0EsQ0FBQyxPQUFPLDJFQUEyRSwrQkFBK0IsQ0FBTTtZQUNoTDtRQUNGO1FBQ0FxQixPQUFPQyxNQUFNLENBQUNvVCxTQUFTO1lBQ3JCMU0sU0FBUyxXQUFXLEdBQUVySSxnREFBbUIsQ0FBQzJILE1BQU1ZLFNBQVM7WUFDekRBLFdBQVdEO1FBQ2I7SUFDRjtJQUNBLElBQUlYLE1BQU11RSxlQUFlLEVBQUU7UUFDekIsSUFBSXpKLElBQXFDLEVBQUU7WUFDekMsSUFBSWtGLE1BQU13RSxzQkFBc0IsRUFBRTtnQkFuM0N4QyxLQW8zQzZDLEdBQUc5TCxpRUFBY0EsQ0FBQyxPQUFPLGdHQUFnRyxxQ0FBcUMsQ0FBTTtZQUMzTTtRQUNGO1FBQ0FxQixPQUFPQyxNQUFNLENBQUNvVCxTQUFTO1lBQ3JCNUksd0JBQXdCLFdBQVcsR0FBRW5NLGdEQUFtQixDQUFDMkgsTUFBTXVFLGVBQWU7WUFDOUVBLGlCQUFpQjVEO1FBQ25CO0lBQ0Y7SUFDQSxJQUFJWCxNQUFNdUQsYUFBYSxFQUFFO1FBQ3ZCLElBQUl6SSxJQUFxQyxFQUFFO1lBQ3pDLElBQUlrRixNQUFNc0QsWUFBWSxFQUFFO2dCQTkzQzlCLEtBKzNDNkMsR0FBRzVLLGlFQUFjQSxDQUFDLE9BQU8sb0ZBQW9GLG1DQUFtQyxDQUFNO1lBQzdMO1FBQ0Y7UUFDQXFCLE9BQU9DLE1BQU0sQ0FBQ29ULFNBQVM7WUFDckI5SixjQUFjLFdBQVcsR0FBRWpMLGdEQUFtQixDQUFDMkgsTUFBTXVELGFBQWE7WUFDbEVBLGVBQWU1QztRQUNqQjtJQUNGO0lBQ0EsT0FBT3lNO0FBQ1Q7QUFDQSxTQUFTQyxtQkFBbUIvTixNQUFNLEVBQUUrSixJQUFJO0lBQ3RDLE9BQU9oUSwrREFBWUEsQ0FBQztRQUNsQnlDLFVBQVV1TixRQUFRLE9BQU8sS0FBSyxJQUFJQSxLQUFLdk4sUUFBUTtRQUMvQzBCLFFBQVExRCxTQUFTLENBQUMsR0FBR3VQLFFBQVEsT0FBTyxLQUFLLElBQUlBLEtBQUs3TCxNQUFNLEVBQUU7WUFDeEQ4UCxvQkFBb0I7UUFDdEI7UUFDQXJELFNBQVM5USxzRUFBbUJBLENBQUM7WUFDM0IwUSxnQkFBZ0JSLFFBQVEsT0FBTyxLQUFLLElBQUlBLEtBQUtRLGNBQWM7WUFDM0RDLGNBQWNULFFBQVEsT0FBTyxLQUFLLElBQUlBLEtBQUtTLFlBQVk7UUFDekQ7UUFDQXlELGVBQWVsRSxRQUFRLE9BQU8sS0FBSyxJQUFJQSxLQUFLa0UsYUFBYTtRQUN6RGpPO1FBQ0E2TjtJQUNGLEdBQUdLLFVBQVU7QUFDZjtBQUV5MUIsQ0FDejFCLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BpYnVza2luLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZGlzdC9pbmRleC5qcz82ZmQ3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUmVhY3QgUm91dGVyIHY2LjIxLjNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgVU5TQUZFX2ludmFyaWFudCwgam9pblBhdGhzLCBtYXRjaFBhdGgsIFVOU0FGRV9nZXRSZXNvbHZlVG9NYXRjaGVzLCBVTlNBRkVfd2FybmluZywgcmVzb2x2ZVRvLCBwYXJzZVBhdGgsIG1hdGNoUm91dGVzLCBBY3Rpb24sIFVOU0FGRV9jb252ZXJ0Um91dGVNYXRjaFRvVWlNYXRjaCwgc3RyaXBCYXNlbmFtZSwgSURMRV9CTE9DS0VSLCBpc1JvdXRlRXJyb3JSZXNwb25zZSwgY3JlYXRlTWVtb3J5SGlzdG9yeSwgQWJvcnRlZERlZmVycmVkRXJyb3IsIGNyZWF0ZVJvdXRlciB9IGZyb20gJ0ByZW1peC1ydW4vcm91dGVyJztcbmV4cG9ydCB7IEFib3J0ZWREZWZlcnJlZEVycm9yLCBBY3Rpb24gYXMgTmF2aWdhdGlvblR5cGUsIGNyZWF0ZVBhdGgsIGRlZmVyLCBnZW5lcmF0ZVBhdGgsIGlzUm91dGVFcnJvclJlc3BvbnNlLCBqc29uLCBtYXRjaFBhdGgsIG1hdGNoUm91dGVzLCBwYXJzZVBhdGgsIHJlZGlyZWN0LCByZWRpcmVjdERvY3VtZW50LCByZXNvbHZlUGF0aCB9IGZyb20gJ0ByZW1peC1ydW4vcm91dGVyJztcblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbi8vIENyZWF0ZSByZWFjdC1zcGVjaWZpYyB0eXBlcyBmcm9tIHRoZSBhZ25vc3RpYyB0eXBlcyBpbiBAcmVtaXgtcnVuL3JvdXRlciB0b1xuLy8gZXhwb3J0IGZyb20gcmVhY3Qtcm91dGVyXG5jb25zdCBEYXRhUm91dGVyQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBEYXRhUm91dGVyQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiRGF0YVJvdXRlclwiO1xufVxuY29uc3QgRGF0YVJvdXRlclN0YXRlQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBEYXRhUm91dGVyU3RhdGVDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJEYXRhUm91dGVyU3RhdGVcIjtcbn1cbmNvbnN0IEF3YWl0Q29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBBd2FpdENvbnRleHQuZGlzcGxheU5hbWUgPSBcIkF3YWl0XCI7XG59XG5cbi8qKlxuICogQSBOYXZpZ2F0b3IgaXMgYSBcImxvY2F0aW9uIGNoYW5nZXJcIjsgaXQncyBob3cgeW91IGdldCB0byBkaWZmZXJlbnQgbG9jYXRpb25zLlxuICpcbiAqIEV2ZXJ5IGhpc3RvcnkgaW5zdGFuY2UgY29uZm9ybXMgdG8gdGhlIE5hdmlnYXRvciBpbnRlcmZhY2UsIGJ1dCB0aGVcbiAqIGRpc3RpbmN0aW9uIGlzIHVzZWZ1bCBwcmltYXJpbHkgd2hlbiBpdCBjb21lcyB0byB0aGUgbG93LWxldmVsIGA8Um91dGVyPmAgQVBJXG4gKiB3aGVyZSBib3RoIHRoZSBsb2NhdGlvbiBhbmQgYSBuYXZpZ2F0b3IgbXVzdCBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGluIG9yZGVyXG4gKiB0byBhdm9pZCBcInRlYXJpbmdcIiB0aGF0IG1heSBvY2N1ciBpbiBhIHN1c3BlbnNlLWVuYWJsZWQgYXBwIGlmIHRoZSBhY3Rpb25cbiAqIGFuZC9vciBsb2NhdGlvbiB3ZXJlIHRvIGJlIHJlYWQgZGlyZWN0bHkgZnJvbSB0aGUgaGlzdG9yeSBpbnN0YW5jZS5cbiAqL1xuXG5jb25zdCBOYXZpZ2F0aW9uQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBOYXZpZ2F0aW9uQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiTmF2aWdhdGlvblwiO1xufVxuY29uc3QgTG9jYXRpb25Db250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIExvY2F0aW9uQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiTG9jYXRpb25cIjtcbn1cbmNvbnN0IFJvdXRlQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KHtcbiAgb3V0bGV0OiBudWxsLFxuICBtYXRjaGVzOiBbXSxcbiAgaXNEYXRhUm91dGU6IGZhbHNlXG59KTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgUm91dGVDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJSb3V0ZVwiO1xufVxuY29uc3QgUm91dGVFcnJvckNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgUm91dGVFcnJvckNvbnRleHQuZGlzcGxheU5hbWUgPSBcIlJvdXRlRXJyb3JcIjtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmdWxsIGhyZWYgZm9yIHRoZSBnaXZlbiBcInRvXCIgdmFsdWUuIFRoaXMgaXMgdXNlZnVsIGZvciBidWlsZGluZ1xuICogY3VzdG9tIGxpbmtzIHRoYXQgYXJlIGFsc28gYWNjZXNzaWJsZSBhbmQgcHJlc2VydmUgcmlnaHQtY2xpY2sgYmVoYXZpb3IuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2UtaHJlZlxuICovXG5mdW5jdGlvbiB1c2VIcmVmKHRvLCBfdGVtcCkge1xuICBsZXQge1xuICAgIHJlbGF0aXZlXG4gIH0gPSBfdGVtcCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDtcbiAgIXVzZUluUm91dGVyQ29udGV4dCgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgLy8gVE9ETzogVGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHRoZXkgc29tZWhvdyBoYXZlIDIgdmVyc2lvbnMgb2YgdGhlXG4gIC8vIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgXCJ1c2VIcmVmKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5cIikgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgbGV0IHtcbiAgICBiYXNlbmFtZSxcbiAgICBuYXZpZ2F0b3JcbiAgfSA9IFJlYWN0LnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICBsZXQge1xuICAgIGhhc2gsXG4gICAgcGF0aG5hbWUsXG4gICAgc2VhcmNoXG4gIH0gPSB1c2VSZXNvbHZlZFBhdGgodG8sIHtcbiAgICByZWxhdGl2ZVxuICB9KTtcbiAgbGV0IGpvaW5lZFBhdGhuYW1lID0gcGF0aG5hbWU7XG5cbiAgLy8gSWYgd2UncmUgb3BlcmF0aW5nIHdpdGhpbiBhIGJhc2VuYW1lLCBwcmVwZW5kIGl0IHRvIHRoZSBwYXRobmFtZSBwcmlvclxuICAvLyB0byBjcmVhdGluZyB0aGUgaHJlZi4gIElmIHRoaXMgaXMgYSByb290IG5hdmlnYXRpb24sIHRoZW4ganVzdCB1c2UgdGhlIHJhd1xuICAvLyBiYXNlbmFtZSB3aGljaCBhbGxvd3MgdGhlIGJhc2VuYW1lIHRvIGhhdmUgZnVsbCBjb250cm9sIG92ZXIgdGhlIHByZXNlbmNlXG4gIC8vIG9mIGEgdHJhaWxpbmcgc2xhc2ggb24gcm9vdCBsaW5rc1xuICBpZiAoYmFzZW5hbWUgIT09IFwiL1wiKSB7XG4gICAgam9pbmVkUGF0aG5hbWUgPSBwYXRobmFtZSA9PT0gXCIvXCIgPyBiYXNlbmFtZSA6IGpvaW5QYXRocyhbYmFzZW5hbWUsIHBhdGhuYW1lXSk7XG4gIH1cbiAgcmV0dXJuIG5hdmlnYXRvci5jcmVhdGVIcmVmKHtcbiAgICBwYXRobmFtZTogam9pbmVkUGF0aG5hbWUsXG4gICAgc2VhcmNoLFxuICAgIGhhc2hcbiAgfSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoaXMgY29tcG9uZW50IGlzIGEgZGVzY2VuZGFudCBvZiBhIGA8Um91dGVyPmAuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2UtaW4tcm91dGVyLWNvbnRleHRcbiAqL1xuZnVuY3Rpb24gdXNlSW5Sb3V0ZXJDb250ZXh0KCkge1xuICByZXR1cm4gUmVhY3QudXNlQ29udGV4dChMb2NhdGlvbkNvbnRleHQpICE9IG51bGw7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBsb2NhdGlvbiBvYmplY3QsIHdoaWNoIHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgVVJMIGluIHdlYlxuICogYnJvd3NlcnMuXG4gKlxuICogTm90ZTogSWYgeW91J3JlIHVzaW5nIHRoaXMgaXQgbWF5IG1lYW4geW91J3JlIGRvaW5nIHNvbWUgb2YgeW91ciBvd25cbiAqIFwicm91dGluZ1wiIGluIHlvdXIgYXBwLCBhbmQgd2UnZCBsaWtlIHRvIGtub3cgd2hhdCB5b3VyIHVzZSBjYXNlIGlzLiBXZSBtYXlcbiAqIGJlIGFibGUgdG8gcHJvdmlkZSBzb21ldGhpbmcgaGlnaGVyLWxldmVsIHRvIGJldHRlciBzdWl0IHlvdXIgbmVlZHMuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2UtbG9jYXRpb25cbiAqL1xuZnVuY3Rpb24gdXNlTG9jYXRpb24oKSB7XG4gICF1c2VJblJvdXRlckNvbnRleHQoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mIHRoZVxuICAvLyByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gIFwidXNlTG9jYXRpb24oKSBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LlwiKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICByZXR1cm4gUmVhY3QudXNlQ29udGV4dChMb2NhdGlvbkNvbnRleHQpLmxvY2F0aW9uO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgbmF2aWdhdGlvbiBhY3Rpb24gd2hpY2ggZGVzY3JpYmVzIGhvdyB0aGUgcm91dGVyIGNhbWUgdG9cbiAqIHRoZSBjdXJyZW50IGxvY2F0aW9uLCBlaXRoZXIgYnkgYSBwb3AsIHB1c2gsIG9yIHJlcGxhY2Ugb24gdGhlIGhpc3Rvcnkgc3RhY2suXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2UtbmF2aWdhdGlvbi10eXBlXG4gKi9cbmZ1bmN0aW9uIHVzZU5hdmlnYXRpb25UeXBlKCkge1xuICByZXR1cm4gUmVhY3QudXNlQ29udGV4dChMb2NhdGlvbkNvbnRleHQpLm5hdmlnYXRpb25UeXBlO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBQYXRoTWF0Y2ggb2JqZWN0IGlmIHRoZSBnaXZlbiBwYXR0ZXJuIG1hdGNoZXMgdGhlIGN1cnJlbnQgVVJMLlxuICogVGhpcyBpcyB1c2VmdWwgZm9yIGNvbXBvbmVudHMgdGhhdCBuZWVkIHRvIGtub3cgXCJhY3RpdmVcIiBzdGF0ZSwgZS5nLlxuICogYDxOYXZMaW5rPmAuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2UtbWF0Y2hcbiAqL1xuZnVuY3Rpb24gdXNlTWF0Y2gocGF0dGVybikge1xuICAhdXNlSW5Sb3V0ZXJDb250ZXh0KCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZiB0aGVcbiAgLy8gcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICBcInVzZU1hdGNoKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5cIikgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgbGV0IHtcbiAgICBwYXRobmFtZVxuICB9ID0gdXNlTG9jYXRpb24oKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gbWF0Y2hQYXRoKHBhdHRlcm4sIHBhdGhuYW1lKSwgW3BhdGhuYW1lLCBwYXR0ZXJuXSk7XG59XG5cbi8qKlxuICogVGhlIGludGVyZmFjZSBmb3IgdGhlIG5hdmlnYXRlKCkgZnVuY3Rpb24gcmV0dXJuZWQgZnJvbSB1c2VOYXZpZ2F0ZSgpLlxuICovXG5cbmNvbnN0IG5hdmlnYXRlRWZmZWN0V2FybmluZyA9IFwiWW91IHNob3VsZCBjYWxsIG5hdmlnYXRlKCkgaW4gYSBSZWFjdC51c2VFZmZlY3QoKSwgbm90IHdoZW4gXCIgKyBcInlvdXIgY29tcG9uZW50IGlzIGZpcnN0IHJlbmRlcmVkLlwiO1xuXG4vLyBNdXRlIHdhcm5pbmdzIGZvciBjYWxscyB0byB1c2VOYXZpZ2F0ZSBpbiBTU1IgZW52aXJvbm1lbnRzXG5mdW5jdGlvbiB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGNiKSB7XG4gIGxldCBpc1N0YXRpYyA9IFJlYWN0LnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpLnN0YXRpYztcbiAgaWYgKCFpc1N0YXRpYykge1xuICAgIC8vIFdlIHNob3VsZCBiZSBhYmxlIHRvIGdldCByaWQgb2YgdGhpcyBvbmNlIHJlYWN0IDE4LjMgaXMgcmVsZWFzZWRcbiAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzI2Mzk1XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KGNiKTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgYW4gaW1wZXJhdGl2ZSBtZXRob2QgZm9yIGNoYW5naW5nIHRoZSBsb2NhdGlvbi4gVXNlZCBieSBgPExpbms+YHMsIGJ1dFxuICogbWF5IGFsc28gYmUgdXNlZCBieSBvdGhlciBlbGVtZW50cyB0byBjaGFuZ2UgdGhlIGxvY2F0aW9uLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vaG9va3MvdXNlLW5hdmlnYXRlXG4gKi9cbmZ1bmN0aW9uIHVzZU5hdmlnYXRlKCkge1xuICBsZXQge1xuICAgIGlzRGF0YVJvdXRlXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIC8vIENvbmRpdGlvbmFsIHVzYWdlIGlzIE9LIGhlcmUgYmVjYXVzZSB0aGUgdXNhZ2Ugb2YgYSBkYXRhIHJvdXRlciBpcyBzdGF0aWNcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gIHJldHVybiBpc0RhdGFSb3V0ZSA/IHVzZU5hdmlnYXRlU3RhYmxlKCkgOiB1c2VOYXZpZ2F0ZVVuc3RhYmxlKCk7XG59XG5mdW5jdGlvbiB1c2VOYXZpZ2F0ZVVuc3RhYmxlKCkge1xuICAhdXNlSW5Sb3V0ZXJDb250ZXh0KCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZiB0aGVcbiAgLy8gcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICBcInVzZU5hdmlnYXRlKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5cIikgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgbGV0IGRhdGFSb3V0ZXJDb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChEYXRhUm91dGVyQ29udGV4dCk7XG4gIGxldCB7XG4gICAgYmFzZW5hbWUsXG4gICAgZnV0dXJlLFxuICAgIG5hdmlnYXRvclxuICB9ID0gUmVhY3QudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCk7XG4gIGxldCB7XG4gICAgbWF0Y2hlc1xuICB9ID0gUmVhY3QudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBsZXQge1xuICAgIHBhdGhuYW1lOiBsb2NhdGlvblBhdGhuYW1lXG4gIH0gPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgcm91dGVQYXRobmFtZXNKc29uID0gSlNPTi5zdHJpbmdpZnkoVU5TQUZFX2dldFJlc29sdmVUb01hdGNoZXMobWF0Y2hlcywgZnV0dXJlLnY3X3JlbGF0aXZlU3BsYXRQYXRoKSk7XG4gIGxldCBhY3RpdmVSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBhY3RpdmVSZWYuY3VycmVudCA9IHRydWU7XG4gIH0pO1xuICBsZXQgbmF2aWdhdGUgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAodG8sIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV93YXJuaW5nKGFjdGl2ZVJlZi5jdXJyZW50LCBuYXZpZ2F0ZUVmZmVjdFdhcm5pbmcpIDogdm9pZCAwO1xuXG4gICAgLy8gU2hvcnQgY2lyY3VpdCBoZXJlIHNpbmNlIGlmIHRoaXMgaGFwcGVucyBvbiBmaXJzdCByZW5kZXIgdGhlIG5hdmlnYXRlXG4gICAgLy8gaXMgdXNlbGVzcyBiZWNhdXNlIHdlIGhhdmVuJ3Qgd2lyZWQgdXAgb3VyIGhpc3RvcnkgbGlzdGVuZXIgeWV0XG4gICAgaWYgKCFhY3RpdmVSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgIGlmICh0eXBlb2YgdG8gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIG5hdmlnYXRvci5nbyh0byk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBwYXRoID0gcmVzb2x2ZVRvKHRvLCBKU09OLnBhcnNlKHJvdXRlUGF0aG5hbWVzSnNvbiksIGxvY2F0aW9uUGF0aG5hbWUsIG9wdGlvbnMucmVsYXRpdmUgPT09IFwicGF0aFwiKTtcblxuICAgIC8vIElmIHdlJ3JlIG9wZXJhdGluZyB3aXRoaW4gYSBiYXNlbmFtZSwgcHJlcGVuZCBpdCB0byB0aGUgcGF0aG5hbWUgcHJpb3JcbiAgICAvLyB0byBoYW5kaW5nIG9mZiB0byBoaXN0b3J5IChidXQgb25seSBpZiB3ZSdyZSBub3QgaW4gYSBkYXRhIHJvdXRlcixcbiAgICAvLyBvdGhlcndpc2UgaXQnbGwgcHJlcGVuZCB0aGUgYmFzZW5hbWUgaW5zaWRlIG9mIHRoZSByb3V0ZXIpLlxuICAgIC8vIElmIHRoaXMgaXMgYSByb290IG5hdmlnYXRpb24sIHRoZW4gd2UgbmF2aWdhdGUgdG8gdGhlIHJhdyBiYXNlbmFtZVxuICAgIC8vIHdoaWNoIGFsbG93cyB0aGUgYmFzZW5hbWUgdG8gaGF2ZSBmdWxsIGNvbnRyb2wgb3ZlciB0aGUgcHJlc2VuY2Ugb2YgYVxuICAgIC8vIHRyYWlsaW5nIHNsYXNoIG9uIHJvb3QgbGlua3NcbiAgICBpZiAoZGF0YVJvdXRlckNvbnRleHQgPT0gbnVsbCAmJiBiYXNlbmFtZSAhPT0gXCIvXCIpIHtcbiAgICAgIHBhdGgucGF0aG5hbWUgPSBwYXRoLnBhdGhuYW1lID09PSBcIi9cIiA/IGJhc2VuYW1lIDogam9pblBhdGhzKFtiYXNlbmFtZSwgcGF0aC5wYXRobmFtZV0pO1xuICAgIH1cbiAgICAoISFvcHRpb25zLnJlcGxhY2UgPyBuYXZpZ2F0b3IucmVwbGFjZSA6IG5hdmlnYXRvci5wdXNoKShwYXRoLCBvcHRpb25zLnN0YXRlLCBvcHRpb25zKTtcbiAgfSwgW2Jhc2VuYW1lLCBuYXZpZ2F0b3IsIHJvdXRlUGF0aG5hbWVzSnNvbiwgbG9jYXRpb25QYXRobmFtZSwgZGF0YVJvdXRlckNvbnRleHRdKTtcbiAgcmV0dXJuIG5hdmlnYXRlO1xufVxuY29uc3QgT3V0bGV0Q29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGNvbnRleHQgKGlmIHByb3ZpZGVkKSBmb3IgdGhlIGNoaWxkIHJvdXRlIGF0IHRoaXMgbGV2ZWwgb2YgdGhlIHJvdXRlXG4gKiBoaWVyYXJjaHkuXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2hvb2tzL3VzZS1vdXRsZXQtY29udGV4dFxuICovXG5mdW5jdGlvbiB1c2VPdXRsZXRDb250ZXh0KCkge1xuICByZXR1cm4gUmVhY3QudXNlQ29udGV4dChPdXRsZXRDb250ZXh0KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBlbGVtZW50IGZvciB0aGUgY2hpbGQgcm91dGUgYXQgdGhpcyBsZXZlbCBvZiB0aGUgcm91dGVcbiAqIGhpZXJhcmNoeS4gVXNlZCBpbnRlcm5hbGx5IGJ5IGA8T3V0bGV0PmAgdG8gcmVuZGVyIGNoaWxkIHJvdXRlcy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2hvb2tzL3VzZS1vdXRsZXRcbiAqL1xuZnVuY3Rpb24gdXNlT3V0bGV0KGNvbnRleHQpIHtcbiAgbGV0IG91dGxldCA9IFJlYWN0LnVzZUNvbnRleHQoUm91dGVDb250ZXh0KS5vdXRsZXQ7XG4gIGlmIChvdXRsZXQpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoT3V0bGV0Q29udGV4dC5Qcm92aWRlciwge1xuICAgICAgdmFsdWU6IGNvbnRleHRcbiAgICB9LCBvdXRsZXQpO1xuICB9XG4gIHJldHVybiBvdXRsZXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBvYmplY3Qgb2Yga2V5L3ZhbHVlIHBhaXJzIG9mIHRoZSBkeW5hbWljIHBhcmFtcyBmcm9tIHRoZSBjdXJyZW50XG4gKiBVUkwgdGhhdCB3ZXJlIG1hdGNoZWQgYnkgdGhlIHJvdXRlIHBhdGguXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2UtcGFyYW1zXG4gKi9cbmZ1bmN0aW9uIHVzZVBhcmFtcygpIHtcbiAgbGV0IHtcbiAgICBtYXRjaGVzXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGxldCByb3V0ZU1hdGNoID0gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gcm91dGVNYXRjaCA/IHJvdXRlTWF0Y2gucGFyYW1zIDoge307XG59XG5cbi8qKlxuICogUmVzb2x2ZXMgdGhlIHBhdGhuYW1lIG9mIHRoZSBnaXZlbiBgdG9gIHZhbHVlIGFnYWluc3QgdGhlIGN1cnJlbnQgbG9jYXRpb24uXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2UtcmVzb2x2ZWQtcGF0aFxuICovXG5mdW5jdGlvbiB1c2VSZXNvbHZlZFBhdGgodG8sIF90ZW1wMikge1xuICBsZXQge1xuICAgIHJlbGF0aXZlXG4gIH0gPSBfdGVtcDIgPT09IHZvaWQgMCA/IHt9IDogX3RlbXAyO1xuICBsZXQge1xuICAgIGZ1dHVyZVxuICB9ID0gUmVhY3QudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCk7XG4gIGxldCB7XG4gICAgbWF0Y2hlc1xuICB9ID0gUmVhY3QudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBsZXQge1xuICAgIHBhdGhuYW1lOiBsb2NhdGlvblBhdGhuYW1lXG4gIH0gPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgcm91dGVQYXRobmFtZXNKc29uID0gSlNPTi5zdHJpbmdpZnkoVU5TQUZFX2dldFJlc29sdmVUb01hdGNoZXMobWF0Y2hlcywgZnV0dXJlLnY3X3JlbGF0aXZlU3BsYXRQYXRoKSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IHJlc29sdmVUbyh0bywgSlNPTi5wYXJzZShyb3V0ZVBhdGhuYW1lc0pzb24pLCBsb2NhdGlvblBhdGhuYW1lLCByZWxhdGl2ZSA9PT0gXCJwYXRoXCIpLCBbdG8sIHJvdXRlUGF0aG5hbWVzSnNvbiwgbG9jYXRpb25QYXRobmFtZSwgcmVsYXRpdmVdKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBlbGVtZW50IG9mIHRoZSByb3V0ZSB0aGF0IG1hdGNoZWQgdGhlIGN1cnJlbnQgbG9jYXRpb24sIHByZXBhcmVkXG4gKiB3aXRoIHRoZSBjb3JyZWN0IGNvbnRleHQgdG8gcmVuZGVyIHRoZSByZW1haW5kZXIgb2YgdGhlIHJvdXRlIHRyZWUuIFJvdXRlXG4gKiBlbGVtZW50cyBpbiB0aGUgdHJlZSBtdXN0IHJlbmRlciBhbiBgPE91dGxldD5gIHRvIHJlbmRlciB0aGVpciBjaGlsZCByb3V0ZSdzXG4gKiBlbGVtZW50LlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vaG9va3MvdXNlLXJvdXRlc1xuICovXG5mdW5jdGlvbiB1c2VSb3V0ZXMocm91dGVzLCBsb2NhdGlvbkFyZykge1xuICByZXR1cm4gdXNlUm91dGVzSW1wbChyb3V0ZXMsIGxvY2F0aW9uQXJnKTtcbn1cblxuLy8gSW50ZXJuYWwgaW1wbGVtZW50YXRpb24gd2l0aCBhY2NlcHQgb3B0aW9uYWwgcGFyYW0gZm9yIFJvdXRlclByb3ZpZGVyIHVzYWdlXG5mdW5jdGlvbiB1c2VSb3V0ZXNJbXBsKHJvdXRlcywgbG9jYXRpb25BcmcsIGRhdGFSb3V0ZXJTdGF0ZSwgZnV0dXJlKSB7XG4gICF1c2VJblJvdXRlckNvbnRleHQoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mIHRoZVxuICAvLyByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gIFwidXNlUm91dGVzKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5cIikgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgbGV0IHtcbiAgICBuYXZpZ2F0b3JcbiAgfSA9IFJlYWN0LnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICBsZXQge1xuICAgIG1hdGNoZXM6IHBhcmVudE1hdGNoZXNcbiAgfSA9IFJlYWN0LnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgbGV0IHJvdXRlTWF0Y2ggPSBwYXJlbnRNYXRjaGVzW3BhcmVudE1hdGNoZXMubGVuZ3RoIC0gMV07XG4gIGxldCBwYXJlbnRQYXJhbXMgPSByb3V0ZU1hdGNoID8gcm91dGVNYXRjaC5wYXJhbXMgOiB7fTtcbiAgbGV0IHBhcmVudFBhdGhuYW1lID0gcm91dGVNYXRjaCA/IHJvdXRlTWF0Y2gucGF0aG5hbWUgOiBcIi9cIjtcbiAgbGV0IHBhcmVudFBhdGhuYW1lQmFzZSA9IHJvdXRlTWF0Y2ggPyByb3V0ZU1hdGNoLnBhdGhuYW1lQmFzZSA6IFwiL1wiO1xuICBsZXQgcGFyZW50Um91dGUgPSByb3V0ZU1hdGNoICYmIHJvdXRlTWF0Y2gucm91dGU7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAvLyBZb3Ugd29uJ3QgZ2V0IGEgd2FybmluZyBhYm91dCAyIGRpZmZlcmVudCA8Um91dGVzPiB1bmRlciBhIDxSb3V0ZT5cbiAgICAvLyB3aXRob3V0IGEgdHJhaWxpbmcgKiwgYnV0IHRoaXMgaXMgYSBiZXN0LWVmZm9ydCB3YXJuaW5nIGFueXdheSBzaW5jZSB3ZVxuICAgIC8vIGNhbm5vdCBldmVuIGdpdmUgdGhlIHdhcm5pbmcgdW5sZXNzIHRoZXkgbGFuZCBhdCB0aGUgcGFyZW50IHJvdXRlLlxuICAgIC8vXG4gICAgLy8gRXhhbXBsZTpcbiAgICAvL1xuICAgIC8vIDxSb3V0ZXM+XG4gICAgLy8gICB7LyogVGhpcyByb3V0ZSBwYXRoIE1VU1QgZW5kIHdpdGggLyogYmVjYXVzZSBvdGhlcndpc2VcbiAgICAvLyAgICAgICBpdCB3aWxsIG5ldmVyIG1hdGNoIC9ibG9nL3Bvc3QvMTIzICovfVxuICAgIC8vICAgPFJvdXRlIHBhdGg9XCJibG9nXCIgZWxlbWVudD17PEJsb2cgLz59IC8+XG4gICAgLy8gICA8Um91dGUgcGF0aD1cImJsb2cvZmVlZFwiIGVsZW1lbnQ9ezxCbG9nRmVlZCAvPn0gLz5cbiAgICAvLyA8L1JvdXRlcz5cbiAgICAvL1xuICAgIC8vIGZ1bmN0aW9uIEJsb2coKSB7XG4gICAgLy8gICByZXR1cm4gKFxuICAgIC8vICAgICA8Um91dGVzPlxuICAgIC8vICAgICAgIDxSb3V0ZSBwYXRoPVwicG9zdC86aWRcIiBlbGVtZW50PXs8UG9zdCAvPn0gLz5cbiAgICAvLyAgICAgPC9Sb3V0ZXM+XG4gICAgLy8gICApO1xuICAgIC8vIH1cbiAgICBsZXQgcGFyZW50UGF0aCA9IHBhcmVudFJvdXRlICYmIHBhcmVudFJvdXRlLnBhdGggfHwgXCJcIjtcbiAgICB3YXJuaW5nT25jZShwYXJlbnRQYXRobmFtZSwgIXBhcmVudFJvdXRlIHx8IHBhcmVudFBhdGguZW5kc1dpdGgoXCIqXCIpLCBcIllvdSByZW5kZXJlZCBkZXNjZW5kYW50IDxSb3V0ZXM+IChvciBjYWxsZWQgYHVzZVJvdXRlcygpYCkgYXQgXCIgKyAoXCJcXFwiXCIgKyBwYXJlbnRQYXRobmFtZSArIFwiXFxcIiAodW5kZXIgPFJvdXRlIHBhdGg9XFxcIlwiICsgcGFyZW50UGF0aCArIFwiXFxcIj4pIGJ1dCB0aGUgXCIpICsgXCJwYXJlbnQgcm91dGUgcGF0aCBoYXMgbm8gdHJhaWxpbmcgXFxcIipcXFwiLiBUaGlzIG1lYW5zIGlmIHlvdSBuYXZpZ2F0ZSBcIiArIFwiZGVlcGVyLCB0aGUgcGFyZW50IHdvbid0IG1hdGNoIGFueW1vcmUgYW5kIHRoZXJlZm9yZSB0aGUgY2hpbGQgXCIgKyBcInJvdXRlcyB3aWxsIG5ldmVyIHJlbmRlci5cXG5cXG5cIiArIChcIlBsZWFzZSBjaGFuZ2UgdGhlIHBhcmVudCA8Um91dGUgcGF0aD1cXFwiXCIgKyBwYXJlbnRQYXRoICsgXCJcXFwiPiB0byA8Um91dGUgXCIpICsgKFwicGF0aD1cXFwiXCIgKyAocGFyZW50UGF0aCA9PT0gXCIvXCIgPyBcIipcIiA6IHBhcmVudFBhdGggKyBcIi8qXCIpICsgXCJcXFwiPi5cIikpO1xuICB9XG4gIGxldCBsb2NhdGlvbkZyb21Db250ZXh0ID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IGxvY2F0aW9uO1xuICBpZiAobG9jYXRpb25BcmcpIHtcbiAgICB2YXIgX3BhcnNlZExvY2F0aW9uQXJnJHBhO1xuICAgIGxldCBwYXJzZWRMb2NhdGlvbkFyZyA9IHR5cGVvZiBsb2NhdGlvbkFyZyA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aChsb2NhdGlvbkFyZykgOiBsb2NhdGlvbkFyZztcbiAgICAhKHBhcmVudFBhdGhuYW1lQmFzZSA9PT0gXCIvXCIgfHwgKChfcGFyc2VkTG9jYXRpb25BcmckcGEgPSBwYXJzZWRMb2NhdGlvbkFyZy5wYXRobmFtZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9wYXJzZWRMb2NhdGlvbkFyZyRwYS5zdGFydHNXaXRoKHBhcmVudFBhdGhuYW1lQmFzZSkpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIFwiV2hlbiBvdmVycmlkaW5nIHRoZSBsb2NhdGlvbiB1c2luZyBgPFJvdXRlcyBsb2NhdGlvbj5gIG9yIGB1c2VSb3V0ZXMocm91dGVzLCBsb2NhdGlvbilgLCBcIiArIFwidGhlIGxvY2F0aW9uIHBhdGhuYW1lIG11c3QgYmVnaW4gd2l0aCB0aGUgcG9ydGlvbiBvZiB0aGUgVVJMIHBhdGhuYW1lIHRoYXQgd2FzIFwiICsgKFwibWF0Y2hlZCBieSBhbGwgcGFyZW50IHJvdXRlcy4gVGhlIGN1cnJlbnQgcGF0aG5hbWUgYmFzZSBpcyBcXFwiXCIgKyBwYXJlbnRQYXRobmFtZUJhc2UgKyBcIlxcXCIgXCIpICsgKFwiYnV0IHBhdGhuYW1lIFxcXCJcIiArIHBhcnNlZExvY2F0aW9uQXJnLnBhdGhuYW1lICsgXCJcXFwiIHdhcyBnaXZlbiBpbiB0aGUgYGxvY2F0aW9uYCBwcm9wLlwiKSkgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBsb2NhdGlvbiA9IHBhcnNlZExvY2F0aW9uQXJnO1xuICB9IGVsc2Uge1xuICAgIGxvY2F0aW9uID0gbG9jYXRpb25Gcm9tQ29udGV4dDtcbiAgfVxuICBsZXQgcGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZSB8fCBcIi9cIjtcbiAgbGV0IHJlbWFpbmluZ1BhdGhuYW1lID0gcGFyZW50UGF0aG5hbWVCYXNlID09PSBcIi9cIiA/IHBhdGhuYW1lIDogcGF0aG5hbWUuc2xpY2UocGFyZW50UGF0aG5hbWVCYXNlLmxlbmd0aCkgfHwgXCIvXCI7XG4gIGxldCBtYXRjaGVzID0gbWF0Y2hSb3V0ZXMocm91dGVzLCB7XG4gICAgcGF0aG5hbWU6IHJlbWFpbmluZ1BhdGhuYW1lXG4gIH0pO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX3dhcm5pbmcocGFyZW50Um91dGUgfHwgbWF0Y2hlcyAhPSBudWxsLCBcIk5vIHJvdXRlcyBtYXRjaGVkIGxvY2F0aW9uIFxcXCJcIiArIGxvY2F0aW9uLnBhdGhuYW1lICsgbG9jYXRpb24uc2VhcmNoICsgbG9jYXRpb24uaGFzaCArIFwiXFxcIiBcIikgOiB2b2lkIDA7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX3dhcm5pbmcobWF0Y2hlcyA9PSBudWxsIHx8IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXS5yb3V0ZS5lbGVtZW50ICE9PSB1bmRlZmluZWQgfHwgbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdLnJvdXRlLkNvbXBvbmVudCAhPT0gdW5kZWZpbmVkIHx8IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXS5yb3V0ZS5sYXp5ICE9PSB1bmRlZmluZWQsIFwiTWF0Y2hlZCBsZWFmIHJvdXRlIGF0IGxvY2F0aW9uIFxcXCJcIiArIGxvY2F0aW9uLnBhdGhuYW1lICsgbG9jYXRpb24uc2VhcmNoICsgbG9jYXRpb24uaGFzaCArIFwiXFxcIiBcIiArIFwiZG9lcyBub3QgaGF2ZSBhbiBlbGVtZW50IG9yIENvbXBvbmVudC4gVGhpcyBtZWFucyBpdCB3aWxsIHJlbmRlciBhbiA8T3V0bGV0IC8+IHdpdGggYSBcIiArIFwibnVsbCB2YWx1ZSBieSBkZWZhdWx0IHJlc3VsdGluZyBpbiBhbiBcXFwiZW1wdHlcXFwiIHBhZ2UuXCIpIDogdm9pZCAwO1xuICB9XG4gIGxldCByZW5kZXJlZE1hdGNoZXMgPSBfcmVuZGVyTWF0Y2hlcyhtYXRjaGVzICYmIG1hdGNoZXMubWFwKG1hdGNoID0+IE9iamVjdC5hc3NpZ24oe30sIG1hdGNoLCB7XG4gICAgcGFyYW1zOiBPYmplY3QuYXNzaWduKHt9LCBwYXJlbnRQYXJhbXMsIG1hdGNoLnBhcmFtcyksXG4gICAgcGF0aG5hbWU6IGpvaW5QYXRocyhbcGFyZW50UGF0aG5hbWVCYXNlLFxuICAgIC8vIFJlLWVuY29kZSBwYXRobmFtZXMgdGhhdCB3ZXJlIGRlY29kZWQgaW5zaWRlIG1hdGNoUm91dGVzXG4gICAgbmF2aWdhdG9yLmVuY29kZUxvY2F0aW9uID8gbmF2aWdhdG9yLmVuY29kZUxvY2F0aW9uKG1hdGNoLnBhdGhuYW1lKS5wYXRobmFtZSA6IG1hdGNoLnBhdGhuYW1lXSksXG4gICAgcGF0aG5hbWVCYXNlOiBtYXRjaC5wYXRobmFtZUJhc2UgPT09IFwiL1wiID8gcGFyZW50UGF0aG5hbWVCYXNlIDogam9pblBhdGhzKFtwYXJlbnRQYXRobmFtZUJhc2UsXG4gICAgLy8gUmUtZW5jb2RlIHBhdGhuYW1lcyB0aGF0IHdlcmUgZGVjb2RlZCBpbnNpZGUgbWF0Y2hSb3V0ZXNcbiAgICBuYXZpZ2F0b3IuZW5jb2RlTG9jYXRpb24gPyBuYXZpZ2F0b3IuZW5jb2RlTG9jYXRpb24obWF0Y2gucGF0aG5hbWVCYXNlKS5wYXRobmFtZSA6IG1hdGNoLnBhdGhuYW1lQmFzZV0pXG4gIH0pKSwgcGFyZW50TWF0Y2hlcywgZGF0YVJvdXRlclN0YXRlLCBmdXR1cmUpO1xuXG4gIC8vIFdoZW4gYSB1c2VyIHBhc3NlcyBpbiBhIGBsb2NhdGlvbkFyZ2AsIHRoZSBhc3NvY2lhdGVkIHJvdXRlcyBuZWVkIHRvXG4gIC8vIGJlIHdyYXBwZWQgaW4gYSBuZXcgYExvY2F0aW9uQ29udGV4dC5Qcm92aWRlcmAgaW4gb3JkZXIgZm9yIGB1c2VMb2NhdGlvbmBcbiAgLy8gdG8gdXNlIHRoZSBzY29wZWQgbG9jYXRpb24gaW5zdGVhZCBvZiB0aGUgZ2xvYmFsIGxvY2F0aW9uLlxuICBpZiAobG9jYXRpb25BcmcgJiYgcmVuZGVyZWRNYXRjaGVzKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KExvY2F0aW9uQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgdmFsdWU6IHtcbiAgICAgICAgbG9jYXRpb246IF9leHRlbmRzKHtcbiAgICAgICAgICBwYXRobmFtZTogXCIvXCIsXG4gICAgICAgICAgc2VhcmNoOiBcIlwiLFxuICAgICAgICAgIGhhc2g6IFwiXCIsXG4gICAgICAgICAgc3RhdGU6IG51bGwsXG4gICAgICAgICAga2V5OiBcImRlZmF1bHRcIlxuICAgICAgICB9LCBsb2NhdGlvbiksXG4gICAgICAgIG5hdmlnYXRpb25UeXBlOiBBY3Rpb24uUG9wXG4gICAgICB9XG4gICAgfSwgcmVuZGVyZWRNYXRjaGVzKTtcbiAgfVxuICByZXR1cm4gcmVuZGVyZWRNYXRjaGVzO1xufVxuZnVuY3Rpb24gRGVmYXVsdEVycm9yQ29tcG9uZW50KCkge1xuICBsZXQgZXJyb3IgPSB1c2VSb3V0ZUVycm9yKCk7XG4gIGxldCBtZXNzYWdlID0gaXNSb3V0ZUVycm9yUmVzcG9uc2UoZXJyb3IpID8gZXJyb3Iuc3RhdHVzICsgXCIgXCIgKyBlcnJvci5zdGF0dXNUZXh0IDogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBKU09OLnN0cmluZ2lmeShlcnJvcik7XG4gIGxldCBzdGFjayA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5zdGFjayA6IG51bGw7XG4gIGxldCBsaWdodGdyZXkgPSBcInJnYmEoMjAwLDIwMCwyMDAsIDAuNSlcIjtcbiAgbGV0IHByZVN0eWxlcyA9IHtcbiAgICBwYWRkaW5nOiBcIjAuNXJlbVwiLFxuICAgIGJhY2tncm91bmRDb2xvcjogbGlnaHRncmV5XG4gIH07XG4gIGxldCBjb2RlU3R5bGVzID0ge1xuICAgIHBhZGRpbmc6IFwiMnB4IDRweFwiLFxuICAgIGJhY2tncm91bmRDb2xvcjogbGlnaHRncmV5XG4gIH07XG4gIGxldCBkZXZJbmZvID0gbnVsbDtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBoYW5kbGVkIGJ5IFJlYWN0IFJvdXRlciBkZWZhdWx0IEVycm9yQm91bmRhcnk6XCIsIGVycm9yKTtcbiAgICBkZXZJbmZvID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwicFwiLCBudWxsLCBcIlxcdUQ4M0RcXHVEQ0JGIEhleSBkZXZlbG9wZXIgXFx1RDgzRFxcdURDNEJcIiksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwicFwiLCBudWxsLCBcIllvdSBjYW4gcHJvdmlkZSBhIHdheSBiZXR0ZXIgVVggdGhhbiB0aGlzIHdoZW4geW91ciBhcHAgdGhyb3dzIGVycm9ycyBieSBwcm92aWRpbmcgeW91ciBvd24gXCIsIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiY29kZVwiLCB7XG4gICAgICBzdHlsZTogY29kZVN0eWxlc1xuICAgIH0sIFwiRXJyb3JCb3VuZGFyeVwiKSwgXCIgb3JcIiwgXCIgXCIsIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiY29kZVwiLCB7XG4gICAgICBzdHlsZTogY29kZVN0eWxlc1xuICAgIH0sIFwiZXJyb3JFbGVtZW50XCIpLCBcIiBwcm9wIG9uIHlvdXIgcm91dGUuXCIpKTtcbiAgfVxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiaDJcIiwgbnVsbCwgXCJVbmV4cGVjdGVkIEFwcGxpY2F0aW9uIEVycm9yIVwiKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoM1wiLCB7XG4gICAgc3R5bGU6IHtcbiAgICAgIGZvbnRTdHlsZTogXCJpdGFsaWNcIlxuICAgIH1cbiAgfSwgbWVzc2FnZSksIHN0YWNrID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwcmVcIiwge1xuICAgIHN0eWxlOiBwcmVTdHlsZXNcbiAgfSwgc3RhY2spIDogbnVsbCwgZGV2SW5mbyk7XG59XG5jb25zdCBkZWZhdWx0RXJyb3JFbGVtZW50ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRGVmYXVsdEVycm9yQ29tcG9uZW50LCBudWxsKTtcbmNsYXNzIFJlbmRlckVycm9yQm91bmRhcnkgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgbG9jYXRpb246IHByb3BzLmxvY2F0aW9uLFxuICAgICAgcmV2YWxpZGF0aW9uOiBwcm9wcy5yZXZhbGlkYXRpb24sXG4gICAgICBlcnJvcjogcHJvcHMuZXJyb3JcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXJyb3I6IGVycm9yXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKHByb3BzLCBzdGF0ZSkge1xuICAgIC8vIFdoZW4gd2UgZ2V0IGludG8gYW4gZXJyb3Igc3RhdGUsIHRoZSB1c2VyIHdpbGwgbGlrZWx5IGNsaWNrIFwiYmFja1wiIHRvIHRoZVxuICAgIC8vIHByZXZpb3VzIHBhZ2UgdGhhdCBkaWRuJ3QgaGF2ZSBhbiBlcnJvci4gQmVjYXVzZSB0aGlzIHdyYXBzIHRoZSBlbnRpcmVcbiAgICAvLyBhcHBsaWNhdGlvbiwgdGhhdCB3aWxsIGhhdmUgbm8gZWZmZWN0LS10aGUgZXJyb3IgcGFnZSBjb250aW51ZXMgdG8gZGlzcGxheS5cbiAgICAvLyBUaGlzIGdpdmVzIHVzIGEgbWVjaGFuaXNtIHRvIHJlY292ZXIgZnJvbSB0aGUgZXJyb3Igd2hlbiB0aGUgbG9jYXRpb24gY2hhbmdlcy5cbiAgICAvL1xuICAgIC8vIFdoZXRoZXIgd2UncmUgaW4gYW4gZXJyb3Igc3RhdGUgb3Igbm90LCB3ZSB1cGRhdGUgdGhlIGxvY2F0aW9uIGluIHN0YXRlXG4gICAgLy8gc28gdGhhdCB3aGVuIHdlIGFyZSBpbiBhbiBlcnJvciBzdGF0ZSwgaXQgZ2V0cyByZXNldCB3aGVuIGEgbmV3IGxvY2F0aW9uXG4gICAgLy8gY29tZXMgaW4gYW5kIHRoZSB1c2VyIHJlY292ZXJzIGZyb20gdGhlIGVycm9yLlxuICAgIGlmIChzdGF0ZS5sb2NhdGlvbiAhPT0gcHJvcHMubG9jYXRpb24gfHwgc3RhdGUucmV2YWxpZGF0aW9uICE9PSBcImlkbGVcIiAmJiBwcm9wcy5yZXZhbGlkYXRpb24gPT09IFwiaWRsZVwiKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlcnJvcjogcHJvcHMuZXJyb3IsXG4gICAgICAgIGxvY2F0aW9uOiBwcm9wcy5sb2NhdGlvbixcbiAgICAgICAgcmV2YWxpZGF0aW9uOiBwcm9wcy5yZXZhbGlkYXRpb25cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgd2UncmUgbm90IGNoYW5naW5nIGxvY2F0aW9ucywgcHJlc2VydmUgdGhlIGxvY2F0aW9uIGJ1dCBzdGlsbCBzdXJmYWNlXG4gICAgLy8gYW55IG5ldyBlcnJvcnMgdGhhdCBtYXkgY29tZSB0aHJvdWdoLiBXZSByZXRhaW4gdGhlIGV4aXN0aW5nIGVycm9yLCB3ZSBkb1xuICAgIC8vIHRoaXMgYmVjYXVzZSB0aGUgZXJyb3IgcHJvdmlkZWQgZnJvbSB0aGUgYXBwIHN0YXRlIG1heSBiZSBjbGVhcmVkIHdpdGhvdXRcbiAgICAvLyB0aGUgbG9jYXRpb24gY2hhbmdpbmcuXG4gICAgcmV0dXJuIHtcbiAgICAgIGVycm9yOiBwcm9wcy5lcnJvciAhPT0gdW5kZWZpbmVkID8gcHJvcHMuZXJyb3IgOiBzdGF0ZS5lcnJvcixcbiAgICAgIGxvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICAgIHJldmFsaWRhdGlvbjogcHJvcHMucmV2YWxpZGF0aW9uIHx8IHN0YXRlLnJldmFsaWRhdGlvblxuICAgIH07XG4gIH1cbiAgY29tcG9uZW50RGlkQ2F0Y2goZXJyb3IsIGVycm9ySW5mbykge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJSZWFjdCBSb3V0ZXIgY2F1Z2h0IHRoZSBmb2xsb3dpbmcgZXJyb3IgZHVyaW5nIHJlbmRlclwiLCBlcnJvciwgZXJyb3JJbmZvKTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuZXJyb3IgIT09IHVuZGVmaW5lZCA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgdmFsdWU6IHRoaXMucHJvcHMucm91dGVDb250ZXh0XG4gICAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVFcnJvckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgIHZhbHVlOiB0aGlzLnN0YXRlLmVycm9yLFxuICAgICAgY2hpbGRyZW46IHRoaXMucHJvcHMuY29tcG9uZW50XG4gICAgfSkpIDogdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgfVxufVxuZnVuY3Rpb24gUmVuZGVyZWRSb3V0ZShfcmVmKSB7XG4gIGxldCB7XG4gICAgcm91dGVDb250ZXh0LFxuICAgIG1hdGNoLFxuICAgIGNoaWxkcmVuXG4gIH0gPSBfcmVmO1xuICBsZXQgZGF0YVJvdXRlckNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KERhdGFSb3V0ZXJDb250ZXh0KTtcblxuICAvLyBUcmFjayBob3cgZGVlcCB3ZSBnb3QgaW4gb3VyIHJlbmRlciBwYXNzIHRvIGVtdWxhdGUgU1NSIGNvbXBvbmVudERpZENhdGNoXG4gIC8vIGluIGEgRGF0YVN0YXRpY1JvdXRlclxuICBpZiAoZGF0YVJvdXRlckNvbnRleHQgJiYgZGF0YVJvdXRlckNvbnRleHQuc3RhdGljICYmIGRhdGFSb3V0ZXJDb250ZXh0LnN0YXRpY0NvbnRleHQgJiYgKG1hdGNoLnJvdXRlLmVycm9yRWxlbWVudCB8fCBtYXRjaC5yb3V0ZS5FcnJvckJvdW5kYXJ5KSkge1xuICAgIGRhdGFSb3V0ZXJDb250ZXh0LnN0YXRpY0NvbnRleHQuX2RlZXBlc3RSZW5kZXJlZEJvdW5kYXJ5SWQgPSBtYXRjaC5yb3V0ZS5pZDtcbiAgfVxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHJvdXRlQ29udGV4dFxuICB9LCBjaGlsZHJlbik7XG59XG5mdW5jdGlvbiBfcmVuZGVyTWF0Y2hlcyhtYXRjaGVzLCBwYXJlbnRNYXRjaGVzLCBkYXRhUm91dGVyU3RhdGUsIGZ1dHVyZSkge1xuICB2YXIgX2RhdGFSb3V0ZXJTdGF0ZTI7XG4gIGlmIChwYXJlbnRNYXRjaGVzID09PSB2b2lkIDApIHtcbiAgICBwYXJlbnRNYXRjaGVzID0gW107XG4gIH1cbiAgaWYgKGRhdGFSb3V0ZXJTdGF0ZSA9PT0gdm9pZCAwKSB7XG4gICAgZGF0YVJvdXRlclN0YXRlID0gbnVsbDtcbiAgfVxuICBpZiAoZnV0dXJlID09PSB2b2lkIDApIHtcbiAgICBmdXR1cmUgPSBudWxsO1xuICB9XG4gIGlmIChtYXRjaGVzID09IG51bGwpIHtcbiAgICB2YXIgX2RhdGFSb3V0ZXJTdGF0ZTtcbiAgICBpZiAoKF9kYXRhUm91dGVyU3RhdGUgPSBkYXRhUm91dGVyU3RhdGUpICE9IG51bGwgJiYgX2RhdGFSb3V0ZXJTdGF0ZS5lcnJvcnMpIHtcbiAgICAgIC8vIERvbid0IGJhaWwgaWYgd2UgaGF2ZSBkYXRhIHJvdXRlciBlcnJvcnMgc28gd2UgY2FuIHJlbmRlciB0aGVtIGluIHRoZVxuICAgICAgLy8gYm91bmRhcnkuICBVc2UgdGhlIHByZS1tYXRjaGVkIChvciBzaGltbWVkKSBtYXRjaGVzXG4gICAgICBtYXRjaGVzID0gZGF0YVJvdXRlclN0YXRlLm1hdGNoZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBsZXQgcmVuZGVyZWRNYXRjaGVzID0gbWF0Y2hlcztcblxuICAvLyBJZiB3ZSBoYXZlIGRhdGEgZXJyb3JzLCB0cmltIG1hdGNoZXMgdG8gdGhlIGhpZ2hlc3QgZXJyb3IgYm91bmRhcnlcbiAgbGV0IGVycm9ycyA9IChfZGF0YVJvdXRlclN0YXRlMiA9IGRhdGFSb3V0ZXJTdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhUm91dGVyU3RhdGUyLmVycm9ycztcbiAgaWYgKGVycm9ycyAhPSBudWxsKSB7XG4gICAgbGV0IGVycm9ySW5kZXggPSByZW5kZXJlZE1hdGNoZXMuZmluZEluZGV4KG0gPT4gbS5yb3V0ZS5pZCAmJiAoZXJyb3JzID09IG51bGwgPyB2b2lkIDAgOiBlcnJvcnNbbS5yb3V0ZS5pZF0pKTtcbiAgICAhKGVycm9ySW5kZXggPj0gMCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCBcIkNvdWxkIG5vdCBmaW5kIGEgbWF0Y2hpbmcgcm91dGUgZm9yIGVycm9ycyBvbiByb3V0ZSBJRHM6IFwiICsgT2JqZWN0LmtleXMoZXJyb3JzKS5qb2luKFwiLFwiKSkgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICByZW5kZXJlZE1hdGNoZXMgPSByZW5kZXJlZE1hdGNoZXMuc2xpY2UoMCwgTWF0aC5taW4ocmVuZGVyZWRNYXRjaGVzLmxlbmd0aCwgZXJyb3JJbmRleCArIDEpKTtcbiAgfVxuXG4gIC8vIElmIHdlJ3JlIGluIGEgcGFydGlhbCBoeWRyYXRpb24gbW9kZSwgZGV0ZWN0IGlmIHdlIG5lZWQgdG8gcmVuZGVyIGRvd24gdG9cbiAgLy8gYSBnaXZlbiBIeWRyYXRlRmFsbGJhY2sgd2hpbGUgd2UgbG9hZCB0aGUgcmVzdCBvZiB0aGUgaHlkcmF0aW9uIGRhdGFcbiAgbGV0IHJlbmRlckZhbGxiYWNrID0gZmFsc2U7XG4gIGxldCBmYWxsYmFja0luZGV4ID0gLTE7XG4gIGlmIChkYXRhUm91dGVyU3RhdGUgJiYgZnV0dXJlICYmIGZ1dHVyZS52N19wYXJ0aWFsSHlkcmF0aW9uKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW5kZXJlZE1hdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBtYXRjaCA9IHJlbmRlcmVkTWF0Y2hlc1tpXTtcbiAgICAgIC8vIFRyYWNrIHRoZSBkZWVwZXN0IGZhbGxiYWNrIHVwIHVudGlsIHRoZSBmaXJzdCByb3V0ZSB3aXRob3V0IGRhdGFcbiAgICAgIGlmIChtYXRjaC5yb3V0ZS5IeWRyYXRlRmFsbGJhY2sgfHwgbWF0Y2gucm91dGUuaHlkcmF0ZUZhbGxiYWNrRWxlbWVudCkge1xuICAgICAgICBmYWxsYmFja0luZGV4ID0gaTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXRjaC5yb3V0ZS5pZCkge1xuICAgICAgICBsZXQge1xuICAgICAgICAgIGxvYWRlckRhdGEsXG4gICAgICAgICAgZXJyb3JzXG4gICAgICAgIH0gPSBkYXRhUm91dGVyU3RhdGU7XG4gICAgICAgIGxldCBuZWVkc1RvUnVuTG9hZGVyID0gbWF0Y2gucm91dGUubG9hZGVyICYmIGxvYWRlckRhdGFbbWF0Y2gucm91dGUuaWRdID09PSB1bmRlZmluZWQgJiYgKCFlcnJvcnMgfHwgZXJyb3JzW21hdGNoLnJvdXRlLmlkXSA9PT0gdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKG1hdGNoLnJvdXRlLmxhenkgfHwgbmVlZHNUb1J1bkxvYWRlcikge1xuICAgICAgICAgIC8vIFdlIGZvdW5kIHRoZSBmaXJzdCByb3V0ZSB0aGF0J3Mgbm90IHJlYWR5IHRvIHJlbmRlciAod2FpdGluZyBvblxuICAgICAgICAgIC8vIGxhenksIG9yIGhhcyBhIGxvYWRlciB0aGF0IGhhc24ndCBydW4geWV0KS4gIEZsYWcgdGhhdCB3ZSBuZWVkIHRvXG4gICAgICAgICAgLy8gcmVuZGVyIGEgZmFsbGJhY2sgYW5kIHJlbmRlciB1cCB1bnRpbCB0aGUgYXBwcm9wcmlhdGUgZmFsbGJhY2tcbiAgICAgICAgICByZW5kZXJGYWxsYmFjayA9IHRydWU7XG4gICAgICAgICAgaWYgKGZhbGxiYWNrSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgcmVuZGVyZWRNYXRjaGVzID0gcmVuZGVyZWRNYXRjaGVzLnNsaWNlKDAsIGZhbGxiYWNrSW5kZXggKyAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVuZGVyZWRNYXRjaGVzID0gW3JlbmRlcmVkTWF0Y2hlc1swXV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZW5kZXJlZE1hdGNoZXMucmVkdWNlUmlnaHQoKG91dGxldCwgbWF0Y2gsIGluZGV4KSA9PiB7XG4gICAgLy8gT25seSBkYXRhIHJvdXRlcnMgaGFuZGxlIGVycm9ycy9mYWxsYmFja3NcbiAgICBsZXQgZXJyb3I7XG4gICAgbGV0IHNob3VsZFJlbmRlckh5ZHJhdGVGYWxsYmFjayA9IGZhbHNlO1xuICAgIGxldCBlcnJvckVsZW1lbnQgPSBudWxsO1xuICAgIGxldCBoeWRyYXRlRmFsbGJhY2tFbGVtZW50ID0gbnVsbDtcbiAgICBpZiAoZGF0YVJvdXRlclN0YXRlKSB7XG4gICAgICBlcnJvciA9IGVycm9ycyAmJiBtYXRjaC5yb3V0ZS5pZCA/IGVycm9yc1ttYXRjaC5yb3V0ZS5pZF0gOiB1bmRlZmluZWQ7XG4gICAgICBlcnJvckVsZW1lbnQgPSBtYXRjaC5yb3V0ZS5lcnJvckVsZW1lbnQgfHwgZGVmYXVsdEVycm9yRWxlbWVudDtcbiAgICAgIGlmIChyZW5kZXJGYWxsYmFjaykge1xuICAgICAgICBpZiAoZmFsbGJhY2tJbmRleCA8IDAgJiYgaW5kZXggPT09IDApIHtcbiAgICAgICAgICB3YXJuaW5nT25jZShcInJvdXRlLWZhbGxiYWNrXCIsIGZhbHNlLCBcIk5vIGBIeWRyYXRlRmFsbGJhY2tgIGVsZW1lbnQgcHJvdmlkZWQgdG8gcmVuZGVyIGR1cmluZyBpbml0aWFsIGh5ZHJhdGlvblwiKTtcbiAgICAgICAgICBzaG91bGRSZW5kZXJIeWRyYXRlRmFsbGJhY2sgPSB0cnVlO1xuICAgICAgICAgIGh5ZHJhdGVGYWxsYmFja0VsZW1lbnQgPSBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKGZhbGxiYWNrSW5kZXggPT09IGluZGV4KSB7XG4gICAgICAgICAgc2hvdWxkUmVuZGVySHlkcmF0ZUZhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgICBoeWRyYXRlRmFsbGJhY2tFbGVtZW50ID0gbWF0Y2gucm91dGUuaHlkcmF0ZUZhbGxiYWNrRWxlbWVudCB8fCBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBtYXRjaGVzID0gcGFyZW50TWF0Y2hlcy5jb25jYXQocmVuZGVyZWRNYXRjaGVzLnNsaWNlKDAsIGluZGV4ICsgMSkpO1xuICAgIGxldCBnZXRDaGlsZHJlbiA9ICgpID0+IHtcbiAgICAgIGxldCBjaGlsZHJlbjtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjaGlsZHJlbiA9IGVycm9yRWxlbWVudDtcbiAgICAgIH0gZWxzZSBpZiAoc2hvdWxkUmVuZGVySHlkcmF0ZUZhbGxiYWNrKSB7XG4gICAgICAgIGNoaWxkcmVuID0gaHlkcmF0ZUZhbGxiYWNrRWxlbWVudDtcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2gucm91dGUuQ29tcG9uZW50KSB7XG4gICAgICAgIC8vIE5vdGU6IFRoaXMgaXMgYSBkZS1vcHRpbWl6ZWQgcGF0aCBzaW5jZSBSZWFjdCB3b24ndCByZS11c2UgdGhlXG4gICAgICAgIC8vIFJlYWN0RWxlbWVudCBzaW5jZSBpdCdzIGlkZW50aXR5IGNoYW5nZXMgd2l0aCBlYWNoIG5ld1xuICAgICAgICAvLyBSZWFjdC5jcmVhdGVFbGVtZW50IGNhbGwuICBXZSBrZWVwIHRoaXMgc28gZm9sa3MgY2FuIHVzZVxuICAgICAgICAvLyBgPFJvdXRlIENvbXBvbmVudD17Li4ufT5gIGluIGA8Um91dGVzPmAgYnV0IGdlbmVyYWxseSBgQ29tcG9uZW50YFxuICAgICAgICAvLyB1c2FnZSBpcyBvbmx5IGFkdmlzZWQgaW4gYFJvdXRlclByb3ZpZGVyYCB3aGVuIHdlIGNhbiBjb252ZXJ0IGl0IHRvXG4gICAgICAgIC8vIGBlbGVtZW50YCBhaGVhZCBvZiB0aW1lLlxuICAgICAgICBjaGlsZHJlbiA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KG1hdGNoLnJvdXRlLkNvbXBvbmVudCwgbnVsbCk7XG4gICAgICB9IGVsc2UgaWYgKG1hdGNoLnJvdXRlLmVsZW1lbnQpIHtcbiAgICAgICAgY2hpbGRyZW4gPSBtYXRjaC5yb3V0ZS5lbGVtZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hpbGRyZW4gPSBvdXRsZXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVuZGVyZWRSb3V0ZSwge1xuICAgICAgICBtYXRjaDogbWF0Y2gsXG4gICAgICAgIHJvdXRlQ29udGV4dDoge1xuICAgICAgICAgIG91dGxldCxcbiAgICAgICAgICBtYXRjaGVzLFxuICAgICAgICAgIGlzRGF0YVJvdXRlOiBkYXRhUm91dGVyU3RhdGUgIT0gbnVsbFxuICAgICAgICB9LFxuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gT25seSB3cmFwIGluIGFuIGVycm9yIGJvdW5kYXJ5IHdpdGhpbiBkYXRhIHJvdXRlciB1c2FnZXMgd2hlbiB3ZSBoYXZlIGFuXG4gICAgLy8gRXJyb3JCb3VuZGFyeS9lcnJvckVsZW1lbnQgb24gdGhpcyByb3V0ZS4gIE90aGVyd2lzZSBsZXQgaXQgYnViYmxlIHVwIHRvXG4gICAgLy8gYW4gYW5jZXN0b3IgRXJyb3JCb3VuZGFyeS9lcnJvckVsZW1lbnRcbiAgICByZXR1cm4gZGF0YVJvdXRlclN0YXRlICYmIChtYXRjaC5yb3V0ZS5FcnJvckJvdW5kYXJ5IHx8IG1hdGNoLnJvdXRlLmVycm9yRWxlbWVudCB8fCBpbmRleCA9PT0gMCkgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZW5kZXJFcnJvckJvdW5kYXJ5LCB7XG4gICAgICBsb2NhdGlvbjogZGF0YVJvdXRlclN0YXRlLmxvY2F0aW9uLFxuICAgICAgcmV2YWxpZGF0aW9uOiBkYXRhUm91dGVyU3RhdGUucmV2YWxpZGF0aW9uLFxuICAgICAgY29tcG9uZW50OiBlcnJvckVsZW1lbnQsXG4gICAgICBlcnJvcjogZXJyb3IsXG4gICAgICBjaGlsZHJlbjogZ2V0Q2hpbGRyZW4oKSxcbiAgICAgIHJvdXRlQ29udGV4dDoge1xuICAgICAgICBvdXRsZXQ6IG51bGwsXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIGlzRGF0YVJvdXRlOiB0cnVlXG4gICAgICB9XG4gICAgfSkgOiBnZXRDaGlsZHJlbigpO1xuICB9LCBudWxsKTtcbn1cbnZhciBEYXRhUm91dGVySG9vayA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoRGF0YVJvdXRlckhvb2spIHtcbiAgRGF0YVJvdXRlckhvb2tbXCJVc2VCbG9ja2VyXCJdID0gXCJ1c2VCbG9ja2VyXCI7XG4gIERhdGFSb3V0ZXJIb29rW1wiVXNlUmV2YWxpZGF0b3JcIl0gPSBcInVzZVJldmFsaWRhdG9yXCI7XG4gIERhdGFSb3V0ZXJIb29rW1wiVXNlTmF2aWdhdGVTdGFibGVcIl0gPSBcInVzZU5hdmlnYXRlXCI7XG4gIHJldHVybiBEYXRhUm91dGVySG9vaztcbn0oRGF0YVJvdXRlckhvb2sgfHwge30pO1xudmFyIERhdGFSb3V0ZXJTdGF0ZUhvb2sgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKERhdGFSb3V0ZXJTdGF0ZUhvb2spIHtcbiAgRGF0YVJvdXRlclN0YXRlSG9va1tcIlVzZUJsb2NrZXJcIl0gPSBcInVzZUJsb2NrZXJcIjtcbiAgRGF0YVJvdXRlclN0YXRlSG9va1tcIlVzZUxvYWRlckRhdGFcIl0gPSBcInVzZUxvYWRlckRhdGFcIjtcbiAgRGF0YVJvdXRlclN0YXRlSG9va1tcIlVzZUFjdGlvbkRhdGFcIl0gPSBcInVzZUFjdGlvbkRhdGFcIjtcbiAgRGF0YVJvdXRlclN0YXRlSG9va1tcIlVzZVJvdXRlRXJyb3JcIl0gPSBcInVzZVJvdXRlRXJyb3JcIjtcbiAgRGF0YVJvdXRlclN0YXRlSG9va1tcIlVzZU5hdmlnYXRpb25cIl0gPSBcInVzZU5hdmlnYXRpb25cIjtcbiAgRGF0YVJvdXRlclN0YXRlSG9va1tcIlVzZVJvdXRlTG9hZGVyRGF0YVwiXSA9IFwidXNlUm91dGVMb2FkZXJEYXRhXCI7XG4gIERhdGFSb3V0ZXJTdGF0ZUhvb2tbXCJVc2VNYXRjaGVzXCJdID0gXCJ1c2VNYXRjaGVzXCI7XG4gIERhdGFSb3V0ZXJTdGF0ZUhvb2tbXCJVc2VSZXZhbGlkYXRvclwiXSA9IFwidXNlUmV2YWxpZGF0b3JcIjtcbiAgRGF0YVJvdXRlclN0YXRlSG9va1tcIlVzZU5hdmlnYXRlU3RhYmxlXCJdID0gXCJ1c2VOYXZpZ2F0ZVwiO1xuICBEYXRhUm91dGVyU3RhdGVIb29rW1wiVXNlUm91dGVJZFwiXSA9IFwidXNlUm91dGVJZFwiO1xuICByZXR1cm4gRGF0YVJvdXRlclN0YXRlSG9vaztcbn0oRGF0YVJvdXRlclN0YXRlSG9vayB8fCB7fSk7XG5mdW5jdGlvbiBnZXREYXRhUm91dGVyQ29uc29sZUVycm9yKGhvb2tOYW1lKSB7XG4gIHJldHVybiBob29rTmFtZSArIFwiIG11c3QgYmUgdXNlZCB3aXRoaW4gYSBkYXRhIHJvdXRlci4gIFNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9yb3V0ZXJzL3BpY2tpbmctYS1yb3V0ZXIuXCI7XG59XG5mdW5jdGlvbiB1c2VEYXRhUm91dGVyQ29udGV4dChob29rTmFtZSkge1xuICBsZXQgY3R4ID0gUmVhY3QudXNlQ29udGV4dChEYXRhUm91dGVyQ29udGV4dCk7XG4gICFjdHggPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCBnZXREYXRhUm91dGVyQ29uc29sZUVycm9yKGhvb2tOYW1lKSkgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGN0eDtcbn1cbmZ1bmN0aW9uIHVzZURhdGFSb3V0ZXJTdGF0ZShob29rTmFtZSkge1xuICBsZXQgc3RhdGUgPSBSZWFjdC51c2VDb250ZXh0KERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQpO1xuICAhc3RhdGUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCBnZXREYXRhUm91dGVyQ29uc29sZUVycm9yKGhvb2tOYW1lKSkgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgcmV0dXJuIHN0YXRlO1xufVxuZnVuY3Rpb24gdXNlUm91dGVDb250ZXh0KGhvb2tOYW1lKSB7XG4gIGxldCByb3V0ZSA9IFJlYWN0LnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgIXJvdXRlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvcihob29rTmFtZSkpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHJldHVybiByb3V0ZTtcbn1cblxuLy8gSW50ZXJuYWwgdmVyc2lvbiB3aXRoIGhvb2tOYW1lLWF3YXJlIGRlYnVnZ2luZ1xuZnVuY3Rpb24gdXNlQ3VycmVudFJvdXRlSWQoaG9va05hbWUpIHtcbiAgbGV0IHJvdXRlID0gdXNlUm91dGVDb250ZXh0KGhvb2tOYW1lKTtcbiAgbGV0IHRoaXNSb3V0ZSA9IHJvdXRlLm1hdGNoZXNbcm91dGUubWF0Y2hlcy5sZW5ndGggLSAxXTtcbiAgIXRoaXNSb3V0ZS5yb3V0ZS5pZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIGhvb2tOYW1lICsgXCIgY2FuIG9ubHkgYmUgdXNlZCBvbiByb3V0ZXMgdGhhdCBjb250YWluIGEgdW5pcXVlIFxcXCJpZFxcXCJcIikgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgcmV0dXJuIHRoaXNSb3V0ZS5yb3V0ZS5pZDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBJRCBmb3IgdGhlIG5lYXJlc3QgY29udGV4dHVhbCByb3V0ZVxuICovXG5mdW5jdGlvbiB1c2VSb3V0ZUlkKCkge1xuICByZXR1cm4gdXNlQ3VycmVudFJvdXRlSWQoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VSb3V0ZUlkKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IG5hdmlnYXRpb24sIGRlZmF1bHRpbmcgdG8gYW4gXCJpZGxlXCIgbmF2aWdhdGlvbiB3aGVuXG4gKiBubyBuYXZpZ2F0aW9uIGlzIGluIHByb2dyZXNzXG4gKi9cbmZ1bmN0aW9uIHVzZU5hdmlnYXRpb24oKSB7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShEYXRhUm91dGVyU3RhdGVIb29rLlVzZU5hdmlnYXRpb24pO1xuICByZXR1cm4gc3RhdGUubmF2aWdhdGlvbjtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcmV2YWxpZGF0ZSBmdW5jdGlvbiBmb3IgbWFudWFsbHkgdHJpZ2dlcmluZyByZXZhbGlkYXRpb24sIGFzIHdlbGxcbiAqIGFzIHRoZSBjdXJyZW50IHN0YXRlIG9mIGFueSBtYW51YWwgcmV2YWxpZGF0aW9uc1xuICovXG5mdW5jdGlvbiB1c2VSZXZhbGlkYXRvcigpIHtcbiAgbGV0IGRhdGFSb3V0ZXJDb250ZXh0ID0gdXNlRGF0YVJvdXRlckNvbnRleHQoRGF0YVJvdXRlckhvb2suVXNlUmV2YWxpZGF0b3IpO1xuICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VSZXZhbGlkYXRvcik7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgcmV2YWxpZGF0ZTogZGF0YVJvdXRlckNvbnRleHQucm91dGVyLnJldmFsaWRhdGUsXG4gICAgc3RhdGU6IHN0YXRlLnJldmFsaWRhdGlvblxuICB9KSwgW2RhdGFSb3V0ZXJDb250ZXh0LnJvdXRlci5yZXZhbGlkYXRlLCBzdGF0ZS5yZXZhbGlkYXRpb25dKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBhY3RpdmUgcm91dGUgbWF0Y2hlcywgdXNlZnVsIGZvciBhY2Nlc3NpbmcgbG9hZGVyRGF0YSBmb3JcbiAqIHBhcmVudC9jaGlsZCByb3V0ZXMgb3IgdGhlIHJvdXRlIFwiaGFuZGxlXCIgcHJvcGVydHlcbiAqL1xuZnVuY3Rpb24gdXNlTWF0Y2hlcygpIHtcbiAgbGV0IHtcbiAgICBtYXRjaGVzLFxuICAgIGxvYWRlckRhdGFcbiAgfSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShEYXRhUm91dGVyU3RhdGVIb29rLlVzZU1hdGNoZXMpO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiBtYXRjaGVzLm1hcChtID0+IFVOU0FGRV9jb252ZXJ0Um91dGVNYXRjaFRvVWlNYXRjaChtLCBsb2FkZXJEYXRhKSksIFttYXRjaGVzLCBsb2FkZXJEYXRhXSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbG9hZGVyIGRhdGEgZm9yIHRoZSBuZWFyZXN0IGFuY2VzdG9yIFJvdXRlIGxvYWRlclxuICovXG5mdW5jdGlvbiB1c2VMb2FkZXJEYXRhKCkge1xuICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VMb2FkZXJEYXRhKTtcbiAgbGV0IHJvdXRlSWQgPSB1c2VDdXJyZW50Um91dGVJZChEYXRhUm91dGVyU3RhdGVIb29rLlVzZUxvYWRlckRhdGEpO1xuICBpZiAoc3RhdGUuZXJyb3JzICYmIHN0YXRlLmVycm9yc1tyb3V0ZUlkXSAhPSBudWxsKSB7XG4gICAgY29uc29sZS5lcnJvcihcIllvdSBjYW5ub3QgYHVzZUxvYWRlckRhdGFgIGluIGFuIGVycm9yRWxlbWVudCAocm91dGVJZDogXCIgKyByb3V0ZUlkICsgXCIpXCIpO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLmxvYWRlckRhdGFbcm91dGVJZF07XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbG9hZGVyRGF0YSBmb3IgdGhlIGdpdmVuIHJvdXRlSWRcbiAqL1xuZnVuY3Rpb24gdXNlUm91dGVMb2FkZXJEYXRhKHJvdXRlSWQpIHtcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlUm91dGVMb2FkZXJEYXRhKTtcbiAgcmV0dXJuIHN0YXRlLmxvYWRlckRhdGFbcm91dGVJZF07XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYWN0aW9uIGRhdGEgZm9yIHRoZSBuZWFyZXN0IGFuY2VzdG9yIFJvdXRlIGFjdGlvblxuICovXG5mdW5jdGlvbiB1c2VBY3Rpb25EYXRhKCkge1xuICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VBY3Rpb25EYXRhKTtcbiAgbGV0IHJvdXRlSWQgPSB1c2VDdXJyZW50Um91dGVJZChEYXRhUm91dGVyU3RhdGVIb29rLlVzZUxvYWRlckRhdGEpO1xuICByZXR1cm4gc3RhdGUuYWN0aW9uRGF0YSA/IHN0YXRlLmFjdGlvbkRhdGFbcm91dGVJZF0gOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbmVhcmVzdCBhbmNlc3RvciBSb3V0ZSBlcnJvciwgd2hpY2ggY291bGQgYmUgYSBsb2FkZXIvYWN0aW9uXG4gKiBlcnJvciBvciBhIHJlbmRlciBlcnJvci4gIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmUgY2FsbGVkIGZyb20geW91clxuICogRXJyb3JCb3VuZGFyeS9lcnJvckVsZW1lbnQgdG8gZGlzcGxheSBhIHByb3BlciBlcnJvciBtZXNzYWdlLlxuICovXG5mdW5jdGlvbiB1c2VSb3V0ZUVycm9yKCkge1xuICB2YXIgX3N0YXRlJGVycm9ycztcbiAgbGV0IGVycm9yID0gUmVhY3QudXNlQ29udGV4dChSb3V0ZUVycm9yQ29udGV4dCk7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShEYXRhUm91dGVyU3RhdGVIb29rLlVzZVJvdXRlRXJyb3IpO1xuICBsZXQgcm91dGVJZCA9IHVzZUN1cnJlbnRSb3V0ZUlkKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlUm91dGVFcnJvcik7XG5cbiAgLy8gSWYgdGhpcyB3YXMgYSByZW5kZXIgZXJyb3IsIHdlIHB1dCBpdCBpbiBhIFJvdXRlRXJyb3IgY29udGV4dCBpbnNpZGVcbiAgLy8gb2YgUmVuZGVyRXJyb3JCb3VuZGFyeVxuICBpZiAoZXJyb3IgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuXG4gIC8vIE90aGVyd2lzZSBsb29rIGZvciBlcnJvcnMgZnJvbSBvdXIgZGF0YSByb3V0ZXIgc3RhdGVcbiAgcmV0dXJuIChfc3RhdGUkZXJyb3JzID0gc3RhdGUuZXJyb3JzKSA9PSBudWxsID8gdm9pZCAwIDogX3N0YXRlJGVycm9yc1tyb3V0ZUlkXTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBoYXBweS1wYXRoIGRhdGEgZnJvbSB0aGUgbmVhcmVzdCBhbmNlc3RvciBgPEF3YWl0IC8+YCB2YWx1ZVxuICovXG5mdW5jdGlvbiB1c2VBc3luY1ZhbHVlKCkge1xuICBsZXQgdmFsdWUgPSBSZWFjdC51c2VDb250ZXh0KEF3YWl0Q29udGV4dCk7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gdm9pZCAwIDogdmFsdWUuX2RhdGE7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZXJyb3IgZnJvbSB0aGUgbmVhcmVzdCBhbmNlc3RvciBgPEF3YWl0IC8+YCB2YWx1ZVxuICovXG5mdW5jdGlvbiB1c2VBc3luY0Vycm9yKCkge1xuICBsZXQgdmFsdWUgPSBSZWFjdC51c2VDb250ZXh0KEF3YWl0Q29udGV4dCk7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gdm9pZCAwIDogdmFsdWUuX2Vycm9yO1xufVxubGV0IGJsb2NrZXJJZCA9IDA7XG5cbi8qKlxuICogQWxsb3cgdGhlIGFwcGxpY2F0aW9uIHRvIGJsb2NrIG5hdmlnYXRpb25zIHdpdGhpbiB0aGUgU1BBIGFuZCBwcmVzZW50IHRoZVxuICogdXNlciBhIGNvbmZpcm1hdGlvbiBkaWFsb2cgdG8gY29uZmlybSB0aGUgbmF2aWdhdGlvbi4gIE1vc3RseSB1c2VkIHRvIGF2b2lkXG4gKiB1c2luZyBoYWxmLWZpbGxlZCBmb3JtIGRhdGEuICBUaGlzIGRvZXMgbm90IGhhbmRsZSBoYXJkLXJlbG9hZHMgb3JcbiAqIGNyb3NzLW9yaWdpbiBuYXZpZ2F0aW9ucy5cbiAqL1xuZnVuY3Rpb24gdXNlQmxvY2tlcihzaG91bGRCbG9jaykge1xuICBsZXQge1xuICAgIHJvdXRlcixcbiAgICBiYXNlbmFtZVxuICB9ID0gdXNlRGF0YVJvdXRlckNvbnRleHQoRGF0YVJvdXRlckhvb2suVXNlQmxvY2tlcik7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShEYXRhUm91dGVyU3RhdGVIb29rLlVzZUJsb2NrZXIpO1xuICBsZXQgW2Jsb2NrZXJLZXksIHNldEJsb2NrZXJLZXldID0gUmVhY3QudXNlU3RhdGUoXCJcIik7XG4gIGxldCBibG9ja2VyRnVuY3Rpb24gPSBSZWFjdC51c2VDYWxsYmFjayhhcmcgPT4ge1xuICAgIGlmICh0eXBlb2Ygc2hvdWxkQmxvY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuICEhc2hvdWxkQmxvY2s7XG4gICAgfVxuICAgIGlmIChiYXNlbmFtZSA9PT0gXCIvXCIpIHtcbiAgICAgIHJldHVybiBzaG91bGRCbG9jayhhcmcpO1xuICAgIH1cblxuICAgIC8vIElmIHRoZXkgcHJvdmlkZWQgdXMgYSBmdW5jdGlvbiBhbmQgd2UndmUgZ290IGFuIGFjdGl2ZSBiYXNlbmFtZSwgc3RyaXBcbiAgICAvLyBpdCBmcm9tIHRoZSBsb2NhdGlvbnMgd2UgZXhwb3NlIHRvIHRoZSB1c2VyIHRvIG1hdGNoIHRoZSBiZWhhdmlvciBvZlxuICAgIC8vIHVzZUxvY2F0aW9uXG4gICAgbGV0IHtcbiAgICAgIGN1cnJlbnRMb2NhdGlvbixcbiAgICAgIG5leHRMb2NhdGlvbixcbiAgICAgIGhpc3RvcnlBY3Rpb25cbiAgICB9ID0gYXJnO1xuICAgIHJldHVybiBzaG91bGRCbG9jayh7XG4gICAgICBjdXJyZW50TG9jYXRpb246IF9leHRlbmRzKHt9LCBjdXJyZW50TG9jYXRpb24sIHtcbiAgICAgICAgcGF0aG5hbWU6IHN0cmlwQmFzZW5hbWUoY3VycmVudExvY2F0aW9uLnBhdGhuYW1lLCBiYXNlbmFtZSkgfHwgY3VycmVudExvY2F0aW9uLnBhdGhuYW1lXG4gICAgICB9KSxcbiAgICAgIG5leHRMb2NhdGlvbjogX2V4dGVuZHMoe30sIG5leHRMb2NhdGlvbiwge1xuICAgICAgICBwYXRobmFtZTogc3RyaXBCYXNlbmFtZShuZXh0TG9jYXRpb24ucGF0aG5hbWUsIGJhc2VuYW1lKSB8fCBuZXh0TG9jYXRpb24ucGF0aG5hbWVcbiAgICAgIH0pLFxuICAgICAgaGlzdG9yeUFjdGlvblxuICAgIH0pO1xuICB9LCBbYmFzZW5hbWUsIHNob3VsZEJsb2NrXSk7XG5cbiAgLy8gVGhpcyBlZmZlY3QgaXMgaW4gY2hhcmdlIG9mIGJsb2NrZXIga2V5IGFzc2lnbm1lbnQgYW5kIGRlbGV0aW9uICh3aGljaCBpc1xuICAvLyB0aWdodGx5IGNvdXBsZWQgdG8gdGhlIGtleSlcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBsZXQga2V5ID0gU3RyaW5nKCsrYmxvY2tlcklkKTtcbiAgICBzZXRCbG9ja2VyS2V5KGtleSk7XG4gICAgcmV0dXJuICgpID0+IHJvdXRlci5kZWxldGVCbG9ja2VyKGtleSk7XG4gIH0sIFtyb3V0ZXJdKTtcblxuICAvLyBUaGlzIGVmZmVjdCBoYW5kbGVzIGFzc2lnbmluZyB0aGUgYmxvY2tlckZ1bmN0aW9uLiAgVGhpcyBpcyB0byBoYW5kbGVcbiAgLy8gdW5zdGFibGUgYmxvY2tlciBmdW5jdGlvbiBpZGVudGl0aWVzLCBhbmQgaGFwcGVucyBvbmx5IGFmdGVyIHRoZSBwcmlvclxuICAvLyBlZmZlY3Qgc28gd2UgZG9uJ3QgZ2V0IGFuIG9ycGhhbmVkIGJsb2NrZXJGdW5jdGlvbiBpbiB0aGUgcm91dGVyIHdpdGggYVxuICAvLyBrZXkgb2YgXCJcIi4gIFVudGlsIHRoZW4gd2UganVzdCBoYXZlIHRoZSBJRExFX0JMT0NLRVIuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGJsb2NrZXJLZXkgIT09IFwiXCIpIHtcbiAgICAgIHJvdXRlci5nZXRCbG9ja2VyKGJsb2NrZXJLZXksIGJsb2NrZXJGdW5jdGlvbik7XG4gICAgfVxuICB9LCBbcm91dGVyLCBibG9ja2VyS2V5LCBibG9ja2VyRnVuY3Rpb25dKTtcblxuICAvLyBQcmVmZXIgdGhlIGJsb2NrZXIgZnJvbSBgc3RhdGVgIG5vdCBgcm91dGVyLnN0YXRlYCBzaW5jZSBEYXRhUm91dGVyQ29udGV4dFxuICAvLyBpcyBtZW1vaXplZCBzbyB0aGlzIGVuc3VyZXMgd2UgdXBkYXRlIG9uIGJsb2NrZXIgc3RhdGUgdXBkYXRlc1xuICByZXR1cm4gYmxvY2tlcktleSAmJiBzdGF0ZS5ibG9ja2Vycy5oYXMoYmxvY2tlcktleSkgPyBzdGF0ZS5ibG9ja2Vycy5nZXQoYmxvY2tlcktleSkgOiBJRExFX0JMT0NLRVI7XG59XG5cbi8qKlxuICogU3RhYmxlIHZlcnNpb24gb2YgdXNlTmF2aWdhdGUgdGhhdCBpcyB1c2VkIHdoZW4gd2UgYXJlIGluIHRoZSBjb250ZXh0IG9mXG4gKiBhIFJvdXRlclByb3ZpZGVyLlxuICovXG5mdW5jdGlvbiB1c2VOYXZpZ2F0ZVN0YWJsZSgpIHtcbiAgbGV0IHtcbiAgICByb3V0ZXJcbiAgfSA9IHVzZURhdGFSb3V0ZXJDb250ZXh0KERhdGFSb3V0ZXJIb29rLlVzZU5hdmlnYXRlU3RhYmxlKTtcbiAgbGV0IGlkID0gdXNlQ3VycmVudFJvdXRlSWQoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VOYXZpZ2F0ZVN0YWJsZSk7XG4gIGxldCBhY3RpdmVSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBhY3RpdmVSZWYuY3VycmVudCA9IHRydWU7XG4gIH0pO1xuICBsZXQgbmF2aWdhdGUgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAodG8sIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV93YXJuaW5nKGFjdGl2ZVJlZi5jdXJyZW50LCBuYXZpZ2F0ZUVmZmVjdFdhcm5pbmcpIDogdm9pZCAwO1xuXG4gICAgLy8gU2hvcnQgY2lyY3VpdCBoZXJlIHNpbmNlIGlmIHRoaXMgaGFwcGVucyBvbiBmaXJzdCByZW5kZXIgdGhlIG5hdmlnYXRlXG4gICAgLy8gaXMgdXNlbGVzcyBiZWNhdXNlIHdlIGhhdmVuJ3Qgd2lyZWQgdXAgb3VyIHJvdXRlciBzdWJzY3JpYmVyIHlldFxuICAgIGlmICghYWN0aXZlUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICBpZiAodHlwZW9mIHRvID09PSBcIm51bWJlclwiKSB7XG4gICAgICByb3V0ZXIubmF2aWdhdGUodG8pO1xuICAgIH0gZWxzZSB7XG4gICAgICByb3V0ZXIubmF2aWdhdGUodG8sIF9leHRlbmRzKHtcbiAgICAgICAgZnJvbVJvdXRlSWQ6IGlkXG4gICAgICB9LCBvcHRpb25zKSk7XG4gICAgfVxuICB9LCBbcm91dGVyLCBpZF0pO1xuICByZXR1cm4gbmF2aWdhdGU7XG59XG5jb25zdCBhbHJlYWR5V2FybmVkID0ge307XG5mdW5jdGlvbiB3YXJuaW5nT25jZShrZXksIGNvbmQsIG1lc3NhZ2UpIHtcbiAgaWYgKCFjb25kICYmICFhbHJlYWR5V2FybmVkW2tleV0pIHtcbiAgICBhbHJlYWR5V2FybmVkW2tleV0gPSB0cnVlO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV93YXJuaW5nKGZhbHNlLCBtZXNzYWdlKSA6IHZvaWQgMDtcbiAgfVxufVxuXG4vKipcbiAgV2VicGFjayArIFJlYWN0IDE3IGZhaWxzIHRvIGNvbXBpbGUgb24gYW55IG9mIHRoZSBmb2xsb3dpbmcgYmVjYXVzZSB3ZWJwYWNrXG4gIGNvbXBsYWlucyB0aGF0IGBzdGFydFRyYW5zaXRpb25gIGRvZXNuJ3QgZXhpc3QgaW4gYFJlYWN0YDpcbiAgKiBpbXBvcnQgeyBzdGFydFRyYW5zaXRpb24gfSBmcm9tIFwicmVhY3RcIlxuICAqIGltcG9ydCAqIGFzIFJlYWN0IGZyb20gZnJvbSBcInJlYWN0XCI7XG4gICAgXCJzdGFydFRyYW5zaXRpb25cIiBpbiBSZWFjdCA/IFJlYWN0LnN0YXJ0VHJhbnNpdGlvbigoKSA9PiBzZXRTdGF0ZSgpKSA6IHNldFN0YXRlKClcbiAgKiBpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIGZyb20gXCJyZWFjdFwiO1xuICAgIFwic3RhcnRUcmFuc2l0aW9uXCIgaW4gUmVhY3QgPyBSZWFjdFtcInN0YXJ0VHJhbnNpdGlvblwiXSgoKSA9PiBzZXRTdGF0ZSgpKSA6IHNldFN0YXRlKClcblxuICBNb3ZpbmcgaXQgdG8gYSBjb25zdGFudCBzdWNoIGFzIHRoZSBmb2xsb3dpbmcgc29sdmVzIHRoZSBXZWJwYWNrL1JlYWN0IDE3IGlzc3VlOlxuICAqIGltcG9ydCAqIGFzIFJlYWN0IGZyb20gZnJvbSBcInJlYWN0XCI7XG4gICAgY29uc3QgU1RBUlRfVFJBTlNJVElPTiA9IFwic3RhcnRUcmFuc2l0aW9uXCI7XG4gICAgU1RBUlRfVFJBTlNJVElPTiBpbiBSZWFjdCA/IFJlYWN0W1NUQVJUX1RSQU5TSVRJT05dKCgpID0+IHNldFN0YXRlKCkpIDogc2V0U3RhdGUoKVxuXG4gIEhvd2V2ZXIsIHRoYXQgaW50cm9kdWNlcyB3ZWJwYWNrL3RlcnNlciBtaW5pZmljYXRpb24gaXNzdWVzIGluIHByb2R1Y3Rpb24gYnVpbGRzXG4gIGluIFJlYWN0IDE4IHdoZXJlIG1pbmlmaWNhdGlvbi9vYmZ1c2NhdGlvbiBlbmRzIHVwIHJlbW92aW5nIHRoZSBjYWxsIG9mXG4gIFJlYWN0LnN0YXJ0VHJhbnNpdGlvbiBlbnRpcmVseSBmcm9tIHRoZSBmaXJzdCBoYWxmIG9mIHRoZSB0ZXJuYXJ5LiAgR3JhYmJpbmdcbiAgdGhpcyBleHBvcnRlZCByZWZlcmVuY2Ugb25jZSB1cCBmcm9udCByZXNvbHZlcyB0aGF0IGlzc3VlLlxuXG4gIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcmVtaXgtcnVuL3JlYWN0LXJvdXRlci9pc3N1ZXMvMTA1NzlcbiovXG5jb25zdCBTVEFSVF9UUkFOU0lUSU9OID0gXCJzdGFydFRyYW5zaXRpb25cIjtcbmNvbnN0IHN0YXJ0VHJhbnNpdGlvbkltcGwgPSBSZWFjdFtTVEFSVF9UUkFOU0lUSU9OXTtcblxuLyoqXG4gKiBHaXZlbiBhIFJlbWl4IFJvdXRlciBpbnN0YW5jZSwgcmVuZGVyIHRoZSBhcHByb3ByaWF0ZSBVSVxuICovXG5mdW5jdGlvbiBSb3V0ZXJQcm92aWRlcihfcmVmKSB7XG4gIGxldCB7XG4gICAgZmFsbGJhY2tFbGVtZW50LFxuICAgIHJvdXRlcixcbiAgICBmdXR1cmVcbiAgfSA9IF9yZWY7XG4gIGxldCBbc3RhdGUsIHNldFN0YXRlSW1wbF0gPSBSZWFjdC51c2VTdGF0ZShyb3V0ZXIuc3RhdGUpO1xuICBsZXQge1xuICAgIHY3X3N0YXJ0VHJhbnNpdGlvblxuICB9ID0gZnV0dXJlIHx8IHt9O1xuICBsZXQgc2V0U3RhdGUgPSBSZWFjdC51c2VDYWxsYmFjayhuZXdTdGF0ZSA9PiB7XG4gICAgaWYgKHY3X3N0YXJ0VHJhbnNpdGlvbiAmJiBzdGFydFRyYW5zaXRpb25JbXBsKSB7XG4gICAgICBzdGFydFRyYW5zaXRpb25JbXBsKCgpID0+IHNldFN0YXRlSW1wbChuZXdTdGF0ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRTdGF0ZUltcGwobmV3U3RhdGUpO1xuICAgIH1cbiAgfSwgW3NldFN0YXRlSW1wbCwgdjdfc3RhcnRUcmFuc2l0aW9uXSk7XG5cbiAgLy8gTmVlZCB0byB1c2UgYSBsYXlvdXQgZWZmZWN0IGhlcmUgc28gd2UgYXJlIHN1YnNjcmliZWQgZWFybHkgZW5vdWdoIHRvXG4gIC8vIHBpY2sgdXAgb24gYW55IHJlbmRlci1kcml2ZW4gcmVkaXJlY3RzL25hdmlnYXRpb25zICh1c2VFZmZlY3QvPE5hdmlnYXRlPilcbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHJvdXRlci5zdWJzY3JpYmUoc2V0U3RhdGUpLCBbcm91dGVyLCBzZXRTdGF0ZV0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV93YXJuaW5nKGZhbGxiYWNrRWxlbWVudCA9PSBudWxsIHx8ICFyb3V0ZXIuZnV0dXJlLnY3X3BhcnRpYWxIeWRyYXRpb24sIFwiYDxSb3V0ZXJQcm92aWRlciBmYWxsYmFja0VsZW1lbnQ+YCBpcyBkZXByZWNhdGVkIHdoZW4gdXNpbmcgXCIgKyBcImB2N19wYXJ0aWFsSHlkcmF0aW9uYCwgdXNlIGEgYEh5ZHJhdGVGYWxsYmFja2AgY29tcG9uZW50IGluc3RlYWRcIikgOiB2b2lkIDA7XG4gICAgLy8gT25seSBsb2cgdGhpcyBvbmNlIG9uIGluaXRpYWwgbW91bnRcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFtdKTtcbiAgbGV0IG5hdmlnYXRvciA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBjcmVhdGVIcmVmOiByb3V0ZXIuY3JlYXRlSHJlZixcbiAgICAgIGVuY29kZUxvY2F0aW9uOiByb3V0ZXIuZW5jb2RlTG9jYXRpb24sXG4gICAgICBnbzogbiA9PiByb3V0ZXIubmF2aWdhdGUobiksXG4gICAgICBwdXNoOiAodG8sIHN0YXRlLCBvcHRzKSA9PiByb3V0ZXIubmF2aWdhdGUodG8sIHtcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5wcmV2ZW50U2Nyb2xsUmVzZXRcbiAgICAgIH0pLFxuICAgICAgcmVwbGFjZTogKHRvLCBzdGF0ZSwgb3B0cykgPT4gcm91dGVyLm5hdmlnYXRlKHRvLCB7XG4gICAgICAgIHJlcGxhY2U6IHRydWUsXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMucHJldmVudFNjcm9sbFJlc2V0XG4gICAgICB9KVxuICAgIH07XG4gIH0sIFtyb3V0ZXJdKTtcbiAgbGV0IGJhc2VuYW1lID0gcm91dGVyLmJhc2VuYW1lIHx8IFwiL1wiO1xuICBsZXQgZGF0YVJvdXRlckNvbnRleHQgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgcm91dGVyLFxuICAgIG5hdmlnYXRvcixcbiAgICBzdGF0aWM6IGZhbHNlLFxuICAgIGJhc2VuYW1lXG4gIH0pLCBbcm91dGVyLCBuYXZpZ2F0b3IsIGJhc2VuYW1lXSk7XG5cbiAgLy8gVGhlIGZyYWdtZW50IGFuZCB7bnVsbH0gaGVyZSBhcmUgaW1wb3J0YW50ISAgV2UgbmVlZCB0aGVtIHRvIGtlZXAgUmVhY3QgMTgnc1xuICAvLyB1c2VJZCBoYXBweSB3aGVuIHdlIGFyZSBzZXJ2ZXItcmVuZGVyaW5nIHNpbmNlIHdlIG1heSBoYXZlIGEgPHNjcmlwdD4gaGVyZVxuICAvLyBjb250YWluaW5nIHRoZSBoeWRyYXRlZCBzZXJ2ZXItc2lkZSBzdGF0aWNDb250ZXh0IChmcm9tIFN0YXRpY1JvdXRlclByb3ZpZGVyKS5cbiAgLy8gdXNlSWQgcmVsaWVzIG9uIHRoZSBjb21wb25lbnQgdHJlZSBzdHJ1Y3R1cmUgdG8gZ2VuZXJhdGUgZGV0ZXJtaW5pc3RpYyBpZCdzXG4gIC8vIHNvIHdlIG5lZWQgdG8gZW5zdXJlIGl0IHJlbWFpbnMgdGhlIHNhbWUgb24gdGhlIGNsaWVudCBldmVuIHRob3VnaFxuICAvLyB3ZSBkb24ndCBuZWVkIHRoZSA8c2NyaXB0PiB0YWdcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChEYXRhUm91dGVyQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBkYXRhUm91dGVyQ29udGV4dFxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChEYXRhUm91dGVyU3RhdGVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHN0YXRlXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlciwge1xuICAgIGJhc2VuYW1lOiBiYXNlbmFtZSxcbiAgICBsb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgbmF2aWdhdGlvblR5cGU6IHN0YXRlLmhpc3RvcnlBY3Rpb24sXG4gICAgbmF2aWdhdG9yOiBuYXZpZ2F0b3IsXG4gICAgZnV0dXJlOiB7XG4gICAgICB2N19yZWxhdGl2ZVNwbGF0UGF0aDogcm91dGVyLmZ1dHVyZS52N19yZWxhdGl2ZVNwbGF0UGF0aFxuICAgIH1cbiAgfSwgc3RhdGUuaW5pdGlhbGl6ZWQgfHwgcm91dGVyLmZ1dHVyZS52N19wYXJ0aWFsSHlkcmF0aW9uID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRGF0YVJvdXRlcywge1xuICAgIHJvdXRlczogcm91dGVyLnJvdXRlcyxcbiAgICBmdXR1cmU6IHJvdXRlci5mdXR1cmUsXG4gICAgc3RhdGU6IHN0YXRlXG4gIH0pIDogZmFsbGJhY2tFbGVtZW50KSkpLCBudWxsKTtcbn1cbmZ1bmN0aW9uIERhdGFSb3V0ZXMoX3JlZjIpIHtcbiAgbGV0IHtcbiAgICByb3V0ZXMsXG4gICAgZnV0dXJlLFxuICAgIHN0YXRlXG4gIH0gPSBfcmVmMjtcbiAgcmV0dXJuIHVzZVJvdXRlc0ltcGwocm91dGVzLCB1bmRlZmluZWQsIHN0YXRlLCBmdXR1cmUpO1xufVxuLyoqXG4gKiBBIGA8Um91dGVyPmAgdGhhdCBzdG9yZXMgYWxsIGVudHJpZXMgaW4gbWVtb3J5LlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vcm91dGVyLWNvbXBvbmVudHMvbWVtb3J5LXJvdXRlclxuICovXG5mdW5jdGlvbiBNZW1vcnlSb3V0ZXIoX3JlZjMpIHtcbiAgbGV0IHtcbiAgICBiYXNlbmFtZSxcbiAgICBjaGlsZHJlbixcbiAgICBpbml0aWFsRW50cmllcyxcbiAgICBpbml0aWFsSW5kZXgsXG4gICAgZnV0dXJlXG4gIH0gPSBfcmVmMztcbiAgbGV0IGhpc3RvcnlSZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgaWYgKGhpc3RvcnlSZWYuY3VycmVudCA9PSBudWxsKSB7XG4gICAgaGlzdG9yeVJlZi5jdXJyZW50ID0gY3JlYXRlTWVtb3J5SGlzdG9yeSh7XG4gICAgICBpbml0aWFsRW50cmllcyxcbiAgICAgIGluaXRpYWxJbmRleCxcbiAgICAgIHY1Q29tcGF0OiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgbGV0IGhpc3RvcnkgPSBoaXN0b3J5UmVmLmN1cnJlbnQ7XG4gIGxldCBbc3RhdGUsIHNldFN0YXRlSW1wbF0gPSBSZWFjdC51c2VTdGF0ZSh7XG4gICAgYWN0aW9uOiBoaXN0b3J5LmFjdGlvbixcbiAgICBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvblxuICB9KTtcbiAgbGV0IHtcbiAgICB2N19zdGFydFRyYW5zaXRpb25cbiAgfSA9IGZ1dHVyZSB8fCB7fTtcbiAgbGV0IHNldFN0YXRlID0gUmVhY3QudXNlQ2FsbGJhY2sobmV3U3RhdGUgPT4ge1xuICAgIHY3X3N0YXJ0VHJhbnNpdGlvbiAmJiBzdGFydFRyYW5zaXRpb25JbXBsID8gc3RhcnRUcmFuc2l0aW9uSW1wbCgoKSA9PiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpKSA6IHNldFN0YXRlSW1wbChuZXdTdGF0ZSk7XG4gIH0sIFtzZXRTdGF0ZUltcGwsIHY3X3N0YXJ0VHJhbnNpdGlvbl0pO1xuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4gaGlzdG9yeS5saXN0ZW4oc2V0U3RhdGUpLCBbaGlzdG9yeSwgc2V0U3RhdGVdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlciwge1xuICAgIGJhc2VuYW1lOiBiYXNlbmFtZSxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgbG9jYXRpb246IHN0YXRlLmxvY2F0aW9uLFxuICAgIG5hdmlnYXRpb25UeXBlOiBzdGF0ZS5hY3Rpb24sXG4gICAgbmF2aWdhdG9yOiBoaXN0b3J5LFxuICAgIGZ1dHVyZTogZnV0dXJlXG4gIH0pO1xufVxuLyoqXG4gKiBDaGFuZ2VzIHRoZSBjdXJyZW50IGxvY2F0aW9uLlxuICpcbiAqIE5vdGU6IFRoaXMgQVBJIGlzIG1vc3RseSB1c2VmdWwgaW4gUmVhY3QuQ29tcG9uZW50IHN1YmNsYXNzZXMgdGhhdCBhcmUgbm90XG4gKiBhYmxlIHRvIHVzZSBob29rcy4gSW4gZnVuY3Rpb25hbCBjb21wb25lbnRzLCB3ZSByZWNvbW1lbmQgeW91IHVzZSB0aGVcbiAqIGB1c2VOYXZpZ2F0ZWAgaG9vayBpbnN0ZWFkLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vY29tcG9uZW50cy9uYXZpZ2F0ZVxuICovXG5mdW5jdGlvbiBOYXZpZ2F0ZShfcmVmNCkge1xuICBsZXQge1xuICAgIHRvLFxuICAgIHJlcGxhY2UsXG4gICAgc3RhdGUsXG4gICAgcmVsYXRpdmVcbiAgfSA9IF9yZWY0O1xuICAhdXNlSW5Sb3V0ZXJDb250ZXh0KCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZlxuICAvLyB0aGUgcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICBcIjxOYXZpZ2F0ZT4gbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5cIikgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgbGV0IHtcbiAgICBmdXR1cmUsXG4gICAgc3RhdGljOiBpc1N0YXRpY1xuICB9ID0gUmVhY3QudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCk7XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV93YXJuaW5nKCFpc1N0YXRpYywgXCI8TmF2aWdhdGU+IG11c3Qgbm90IGJlIHVzZWQgb24gdGhlIGluaXRpYWwgcmVuZGVyIGluIGEgPFN0YXRpY1JvdXRlcj4uIFwiICsgXCJUaGlzIGlzIGEgbm8tb3AsIGJ1dCB5b3Ugc2hvdWxkIG1vZGlmeSB5b3VyIGNvZGUgc28gdGhlIDxOYXZpZ2F0ZT4gaXMgXCIgKyBcIm9ubHkgZXZlciByZW5kZXJlZCBpbiByZXNwb25zZSB0byBzb21lIHVzZXIgaW50ZXJhY3Rpb24gb3Igc3RhdGUgY2hhbmdlLlwiKSA6IHZvaWQgMDtcbiAgbGV0IHtcbiAgICBtYXRjaGVzXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGxldCB7XG4gICAgcGF0aG5hbWU6IGxvY2F0aW9uUGF0aG5hbWVcbiAgfSA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCBuYXZpZ2F0ZSA9IHVzZU5hdmlnYXRlKCk7XG5cbiAgLy8gUmVzb2x2ZSB0aGUgcGF0aCBvdXRzaWRlIG9mIHRoZSBlZmZlY3Qgc28gdGhhdCB3aGVuIGVmZmVjdHMgcnVuIHR3aWNlIGluXG4gIC8vIFN0cmljdE1vZGUgdGhleSBuYXZpZ2F0ZSB0byB0aGUgc2FtZSBwbGFjZVxuICBsZXQgcGF0aCA9IHJlc29sdmVUbyh0bywgVU5TQUZFX2dldFJlc29sdmVUb01hdGNoZXMobWF0Y2hlcywgZnV0dXJlLnY3X3JlbGF0aXZlU3BsYXRQYXRoKSwgbG9jYXRpb25QYXRobmFtZSwgcmVsYXRpdmUgPT09IFwicGF0aFwiKTtcbiAgbGV0IGpzb25QYXRoID0gSlNPTi5zdHJpbmdpZnkocGF0aCk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiBuYXZpZ2F0ZShKU09OLnBhcnNlKGpzb25QYXRoKSwge1xuICAgIHJlcGxhY2UsXG4gICAgc3RhdGUsXG4gICAgcmVsYXRpdmVcbiAgfSksIFtuYXZpZ2F0ZSwganNvblBhdGgsIHJlbGF0aXZlLCByZXBsYWNlLCBzdGF0ZV0pO1xuICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogUmVuZGVycyB0aGUgY2hpbGQgcm91dGUncyBlbGVtZW50LCBpZiB0aGVyZSBpcyBvbmUuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9jb21wb25lbnRzL291dGxldFxuICovXG5mdW5jdGlvbiBPdXRsZXQocHJvcHMpIHtcbiAgcmV0dXJuIHVzZU91dGxldChwcm9wcy5jb250ZXh0KTtcbn1cbi8qKlxuICogRGVjbGFyZXMgYW4gZWxlbWVudCB0aGF0IHNob3VsZCBiZSByZW5kZXJlZCBhdCBhIGNlcnRhaW4gVVJMIHBhdGguXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9jb21wb25lbnRzL3JvdXRlXG4gKi9cbmZ1bmN0aW9uIFJvdXRlKF9wcm9wcykge1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCBcIkEgPFJvdXRlPiBpcyBvbmx5IGV2ZXIgdG8gYmUgdXNlZCBhcyB0aGUgY2hpbGQgb2YgPFJvdXRlcz4gZWxlbWVudCwgXCIgKyBcIm5ldmVyIHJlbmRlcmVkIGRpcmVjdGx5LiBQbGVhc2Ugd3JhcCB5b3VyIDxSb3V0ZT4gaW4gYSA8Um91dGVzPi5cIikgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA7XG59XG4vKipcbiAqIFByb3ZpZGVzIGxvY2F0aW9uIGNvbnRleHQgZm9yIHRoZSByZXN0IG9mIHRoZSBhcHAuXG4gKlxuICogTm90ZTogWW91IHVzdWFsbHkgd29uJ3QgcmVuZGVyIGEgYDxSb3V0ZXI+YCBkaXJlY3RseS4gSW5zdGVhZCwgeW91J2xsIHJlbmRlciBhXG4gKiByb3V0ZXIgdGhhdCBpcyBtb3JlIHNwZWNpZmljIHRvIHlvdXIgZW52aXJvbm1lbnQgc3VjaCBhcyBhIGA8QnJvd3NlclJvdXRlcj5gXG4gKiBpbiB3ZWIgYnJvd3NlcnMgb3IgYSBgPFN0YXRpY1JvdXRlcj5gIGZvciBzZXJ2ZXIgcmVuZGVyaW5nLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vcm91dGVyLWNvbXBvbmVudHMvcm91dGVyXG4gKi9cbmZ1bmN0aW9uIFJvdXRlcihfcmVmNSkge1xuICBsZXQge1xuICAgIGJhc2VuYW1lOiBiYXNlbmFtZVByb3AgPSBcIi9cIixcbiAgICBjaGlsZHJlbiA9IG51bGwsXG4gICAgbG9jYXRpb246IGxvY2F0aW9uUHJvcCxcbiAgICBuYXZpZ2F0aW9uVHlwZSA9IEFjdGlvbi5Qb3AsXG4gICAgbmF2aWdhdG9yLFxuICAgIHN0YXRpYzogc3RhdGljUHJvcCA9IGZhbHNlLFxuICAgIGZ1dHVyZVxuICB9ID0gX3JlZjU7XG4gICEhdXNlSW5Sb3V0ZXJDb250ZXh0KCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCBcIllvdSBjYW5ub3QgcmVuZGVyIGEgPFJvdXRlcj4gaW5zaWRlIGFub3RoZXIgPFJvdXRlcj4uXCIgKyBcIiBZb3Ugc2hvdWxkIG5ldmVyIGhhdmUgbW9yZSB0aGFuIG9uZSBpbiB5b3VyIGFwcC5cIikgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAvLyBQcmVzZXJ2ZSB0cmFpbGluZyBzbGFzaGVzIG9uIGJhc2VuYW1lLCBzbyB3ZSBjYW4gbGV0IHRoZSB1c2VyIGNvbnRyb2xcbiAgLy8gdGhlIGVuZm9yY2VtZW50IG9mIHRyYWlsaW5nIHNsYXNoZXMgdGhyb3VnaG91dCB0aGUgYXBwXG4gIGxldCBiYXNlbmFtZSA9IGJhc2VuYW1lUHJvcC5yZXBsYWNlKC9eXFwvKi8sIFwiL1wiKTtcbiAgbGV0IG5hdmlnYXRpb25Db250ZXh0ID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIGJhc2VuYW1lLFxuICAgIG5hdmlnYXRvcixcbiAgICBzdGF0aWM6IHN0YXRpY1Byb3AsXG4gICAgZnV0dXJlOiBfZXh0ZW5kcyh7XG4gICAgICB2N19yZWxhdGl2ZVNwbGF0UGF0aDogZmFsc2VcbiAgICB9LCBmdXR1cmUpXG4gIH0pLCBbYmFzZW5hbWUsIGZ1dHVyZSwgbmF2aWdhdG9yLCBzdGF0aWNQcm9wXSk7XG4gIGlmICh0eXBlb2YgbG9jYXRpb25Qcm9wID09PSBcInN0cmluZ1wiKSB7XG4gICAgbG9jYXRpb25Qcm9wID0gcGFyc2VQYXRoKGxvY2F0aW9uUHJvcCk7XG4gIH1cbiAgbGV0IHtcbiAgICBwYXRobmFtZSA9IFwiL1wiLFxuICAgIHNlYXJjaCA9IFwiXCIsXG4gICAgaGFzaCA9IFwiXCIsXG4gICAgc3RhdGUgPSBudWxsLFxuICAgIGtleSA9IFwiZGVmYXVsdFwiXG4gIH0gPSBsb2NhdGlvblByb3A7XG4gIGxldCBsb2NhdGlvbkNvbnRleHQgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBsZXQgdHJhaWxpbmdQYXRobmFtZSA9IHN0cmlwQmFzZW5hbWUocGF0aG5hbWUsIGJhc2VuYW1lKTtcbiAgICBpZiAodHJhaWxpbmdQYXRobmFtZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvY2F0aW9uOiB7XG4gICAgICAgIHBhdGhuYW1lOiB0cmFpbGluZ1BhdGhuYW1lLFxuICAgICAgICBzZWFyY2gsXG4gICAgICAgIGhhc2gsXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBrZXlcbiAgICAgIH0sXG4gICAgICBuYXZpZ2F0aW9uVHlwZVxuICAgIH07XG4gIH0sIFtiYXNlbmFtZSwgcGF0aG5hbWUsIHNlYXJjaCwgaGFzaCwgc3RhdGUsIGtleSwgbmF2aWdhdGlvblR5cGVdKTtcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX3dhcm5pbmcobG9jYXRpb25Db250ZXh0ICE9IG51bGwsIFwiPFJvdXRlciBiYXNlbmFtZT1cXFwiXCIgKyBiYXNlbmFtZSArIFwiXFxcIj4gaXMgbm90IGFibGUgdG8gbWF0Y2ggdGhlIFVSTCBcIiArIChcIlxcXCJcIiArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaCArIFwiXFxcIiBiZWNhdXNlIGl0IGRvZXMgbm90IHN0YXJ0IHdpdGggdGhlIFwiKSArIFwiYmFzZW5hbWUsIHNvIHRoZSA8Um91dGVyPiB3b24ndCByZW5kZXIgYW55dGhpbmcuXCIpIDogdm9pZCAwO1xuICBpZiAobG9jYXRpb25Db250ZXh0ID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTmF2aWdhdGlvbkNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogbmF2aWdhdGlvbkNvbnRleHRcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTG9jYXRpb25Db250ZXh0LlByb3ZpZGVyLCB7XG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgIHZhbHVlOiBsb2NhdGlvbkNvbnRleHRcbiAgfSkpO1xufVxuLyoqXG4gKiBBIGNvbnRhaW5lciBmb3IgYSBuZXN0ZWQgdHJlZSBvZiBgPFJvdXRlPmAgZWxlbWVudHMgdGhhdCByZW5kZXJzIHRoZSBicmFuY2hcbiAqIHRoYXQgYmVzdCBtYXRjaGVzIHRoZSBjdXJyZW50IGxvY2F0aW9uLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vY29tcG9uZW50cy9yb3V0ZXNcbiAqL1xuZnVuY3Rpb24gUm91dGVzKF9yZWY2KSB7XG4gIGxldCB7XG4gICAgY2hpbGRyZW4sXG4gICAgbG9jYXRpb25cbiAgfSA9IF9yZWY2O1xuICByZXR1cm4gdXNlUm91dGVzKGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbihjaGlsZHJlbiksIGxvY2F0aW9uKTtcbn1cbi8qKlxuICogQ29tcG9uZW50IHRvIHVzZSBmb3IgcmVuZGVyaW5nIGxhemlseSBsb2FkZWQgZGF0YSBmcm9tIHJldHVybmluZyBkZWZlcigpXG4gKiBpbiBhIGxvYWRlciBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBBd2FpdChfcmVmNykge1xuICBsZXQge1xuICAgIGNoaWxkcmVuLFxuICAgIGVycm9yRWxlbWVudCxcbiAgICByZXNvbHZlXG4gIH0gPSBfcmVmNztcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEF3YWl0RXJyb3JCb3VuZGFyeSwge1xuICAgIHJlc29sdmU6IHJlc29sdmUsXG4gICAgZXJyb3JFbGVtZW50OiBlcnJvckVsZW1lbnRcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVzb2x2ZUF3YWl0LCBudWxsLCBjaGlsZHJlbikpO1xufVxudmFyIEF3YWl0UmVuZGVyU3RhdHVzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChBd2FpdFJlbmRlclN0YXR1cykge1xuICBBd2FpdFJlbmRlclN0YXR1c1tBd2FpdFJlbmRlclN0YXR1c1tcInBlbmRpbmdcIl0gPSAwXSA9IFwicGVuZGluZ1wiO1xuICBBd2FpdFJlbmRlclN0YXR1c1tBd2FpdFJlbmRlclN0YXR1c1tcInN1Y2Nlc3NcIl0gPSAxXSA9IFwic3VjY2Vzc1wiO1xuICBBd2FpdFJlbmRlclN0YXR1c1tBd2FpdFJlbmRlclN0YXR1c1tcImVycm9yXCJdID0gMl0gPSBcImVycm9yXCI7XG4gIHJldHVybiBBd2FpdFJlbmRlclN0YXR1cztcbn0oQXdhaXRSZW5kZXJTdGF0dXMgfHwge30pO1xuY29uc3QgbmV2ZXJTZXR0bGVkUHJvbWlzZSA9IG5ldyBQcm9taXNlKCgpID0+IHt9KTtcbmNsYXNzIEF3YWl0RXJyb3JCb3VuZGFyeSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBlcnJvcjogbnVsbFxuICAgIH07XG4gIH1cbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihlcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICBlcnJvclxuICAgIH07XG4gIH1cbiAgY29tcG9uZW50RGlkQ2F0Y2goZXJyb3IsIGVycm9ySW5mbykge1xuICAgIGNvbnNvbGUuZXJyb3IoXCI8QXdhaXQ+IGNhdWdodCB0aGUgZm9sbG93aW5nIGVycm9yIGR1cmluZyByZW5kZXJcIiwgZXJyb3IsIGVycm9ySW5mbyk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGxldCB7XG4gICAgICBjaGlsZHJlbixcbiAgICAgIGVycm9yRWxlbWVudCxcbiAgICAgIHJlc29sdmVcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBsZXQgcHJvbWlzZSA9IG51bGw7XG4gICAgbGV0IHN0YXR1cyA9IEF3YWl0UmVuZGVyU3RhdHVzLnBlbmRpbmc7XG4gICAgaWYgKCEocmVzb2x2ZSBpbnN0YW5jZW9mIFByb21pc2UpKSB7XG4gICAgICAvLyBEaWRuJ3QgZ2V0IGEgcHJvbWlzZSAtIHByb3ZpZGUgYXMgYSByZXNvbHZlZCBwcm9taXNlXG4gICAgICBzdGF0dXMgPSBBd2FpdFJlbmRlclN0YXR1cy5zdWNjZXNzO1xuICAgICAgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX3RyYWNrZWRcIiwge1xuICAgICAgICBnZXQ6ICgpID0+IHRydWVcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX2RhdGFcIiwge1xuICAgICAgICBnZXQ6ICgpID0+IHJlc29sdmVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZS5lcnJvcikge1xuICAgICAgLy8gQ2F1Z2h0IGEgcmVuZGVyIGVycm9yLCBwcm92aWRlIGl0IGFzIGEgcmVqZWN0ZWQgcHJvbWlzZVxuICAgICAgc3RhdHVzID0gQXdhaXRSZW5kZXJTdGF0dXMuZXJyb3I7XG4gICAgICBsZXQgcmVuZGVyRXJyb3IgPSB0aGlzLnN0YXRlLmVycm9yO1xuICAgICAgcHJvbWlzZSA9IFByb21pc2UucmVqZWN0KCkuY2F0Y2goKCkgPT4ge30pOyAvLyBBdm9pZCB1bmhhbmRsZWQgcmVqZWN0aW9uIHdhcm5pbmdzXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgXCJfdHJhY2tlZFwiLCB7XG4gICAgICAgIGdldDogKCkgPT4gdHJ1ZVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgXCJfZXJyb3JcIiwge1xuICAgICAgICBnZXQ6ICgpID0+IHJlbmRlckVycm9yXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHJlc29sdmUuX3RyYWNrZWQpIHtcbiAgICAgIC8vIEFscmVhZHkgdHJhY2tlZCBwcm9taXNlIC0gY2hlY2sgY29udGVudHNcbiAgICAgIHByb21pc2UgPSByZXNvbHZlO1xuICAgICAgc3RhdHVzID0gcHJvbWlzZS5fZXJyb3IgIT09IHVuZGVmaW5lZCA/IEF3YWl0UmVuZGVyU3RhdHVzLmVycm9yIDogcHJvbWlzZS5fZGF0YSAhPT0gdW5kZWZpbmVkID8gQXdhaXRSZW5kZXJTdGF0dXMuc3VjY2VzcyA6IEF3YWl0UmVuZGVyU3RhdHVzLnBlbmRpbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJhdyAodW50cmFja2VkKSBwcm9taXNlIC0gdHJhY2sgaXRcbiAgICAgIHN0YXR1cyA9IEF3YWl0UmVuZGVyU3RhdHVzLnBlbmRpbmc7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzb2x2ZSwgXCJfdHJhY2tlZFwiLCB7XG4gICAgICAgIGdldDogKCkgPT4gdHJ1ZVxuICAgICAgfSk7XG4gICAgICBwcm9taXNlID0gcmVzb2x2ZS50aGVuKGRhdGEgPT4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc29sdmUsIFwiX2RhdGFcIiwge1xuICAgICAgICBnZXQ6ICgpID0+IGRhdGFcbiAgICAgIH0pLCBlcnJvciA9PiBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzb2x2ZSwgXCJfZXJyb3JcIiwge1xuICAgICAgICBnZXQ6ICgpID0+IGVycm9yXG4gICAgICB9KSk7XG4gICAgfVxuICAgIGlmIChzdGF0dXMgPT09IEF3YWl0UmVuZGVyU3RhdHVzLmVycm9yICYmIHByb21pc2UuX2Vycm9yIGluc3RhbmNlb2YgQWJvcnRlZERlZmVycmVkRXJyb3IpIHtcbiAgICAgIC8vIEZyZWV6ZSB0aGUgVUkgYnkgdGhyb3dpbmcgYSBuZXZlciByZXNvbHZlZCBwcm9taXNlXG4gICAgICB0aHJvdyBuZXZlclNldHRsZWRQcm9taXNlO1xuICAgIH1cbiAgICBpZiAoc3RhdHVzID09PSBBd2FpdFJlbmRlclN0YXR1cy5lcnJvciAmJiAhZXJyb3JFbGVtZW50KSB7XG4gICAgICAvLyBObyBlcnJvckVsZW1lbnQsIHRocm93IHRvIHRoZSBuZWFyZXN0IHJvdXRlLWxldmVsIGVycm9yIGJvdW5kYXJ5XG4gICAgICB0aHJvdyBwcm9taXNlLl9lcnJvcjtcbiAgICB9XG4gICAgaWYgKHN0YXR1cyA9PT0gQXdhaXRSZW5kZXJTdGF0dXMuZXJyb3IpIHtcbiAgICAgIC8vIFJlbmRlciB2aWEgb3VyIGVycm9yRWxlbWVudFxuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEF3YWl0Q29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogcHJvbWlzZSxcbiAgICAgICAgY2hpbGRyZW46IGVycm9yRWxlbWVudFxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzdGF0dXMgPT09IEF3YWl0UmVuZGVyU3RhdHVzLnN1Y2Nlc3MpIHtcbiAgICAgIC8vIFJlbmRlciBjaGlsZHJlbiB3aXRoIHJlc29sdmVkIHZhbHVlXG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQXdhaXRDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiBwcm9taXNlLFxuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFRocm93IHRvIHRoZSBzdXNwZW5zZSBib3VuZGFyeVxuICAgIHRocm93IHByb21pc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogSW5kaXJlY3Rpb24gdG8gbGV2ZXJhZ2UgdXNlQXN5bmNWYWx1ZSBmb3IgYSByZW5kZXItcHJvcCBBUEkgb24gYDxBd2FpdD5gXG4gKi9cbmZ1bmN0aW9uIFJlc29sdmVBd2FpdChfcmVmOCkge1xuICBsZXQge1xuICAgIGNoaWxkcmVuXG4gIH0gPSBfcmVmODtcbiAgbGV0IGRhdGEgPSB1c2VBc3luY1ZhbHVlKCk7XG4gIGxldCB0b1JlbmRlciA9IHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJmdW5jdGlvblwiID8gY2hpbGRyZW4oZGF0YSkgOiBjaGlsZHJlbjtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCB0b1JlbmRlcik7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFVUSUxTXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQ3JlYXRlcyBhIHJvdXRlIGNvbmZpZyBmcm9tIGEgUmVhY3QgXCJjaGlsZHJlblwiIG9iamVjdCwgd2hpY2ggaXMgdXN1YWxseVxuICogZWl0aGVyIGEgYDxSb3V0ZT5gIGVsZW1lbnQgb3IgYW4gYXJyYXkgb2YgdGhlbS4gVXNlZCBpbnRlcm5hbGx5IGJ5XG4gKiBgPFJvdXRlcz5gIHRvIGNyZWF0ZSBhIHJvdXRlIGNvbmZpZyBmcm9tIGl0cyBjaGlsZHJlbi5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL3V0aWxzL2NyZWF0ZS1yb3V0ZXMtZnJvbS1jaGlsZHJlblxuICovXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4oY2hpbGRyZW4sIHBhcmVudFBhdGgpIHtcbiAgaWYgKHBhcmVudFBhdGggPT09IHZvaWQgMCkge1xuICAgIHBhcmVudFBhdGggPSBbXTtcbiAgfVxuICBsZXQgcm91dGVzID0gW107XG4gIFJlYWN0LkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIChlbGVtZW50LCBpbmRleCkgPT4ge1xuICAgIGlmICghIC8qI19fUFVSRV9fKi9SZWFjdC5pc1ZhbGlkRWxlbWVudChlbGVtZW50KSkge1xuICAgICAgLy8gSWdub3JlIG5vbi1lbGVtZW50cy4gVGhpcyBhbGxvd3MgcGVvcGxlIHRvIG1vcmUgZWFzaWx5IGlubGluZVxuICAgICAgLy8gY29uZGl0aW9uYWxzIGluIHRoZWlyIHJvdXRlIGNvbmZpZy5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHRyZWVQYXRoID0gWy4uLnBhcmVudFBhdGgsIGluZGV4XTtcbiAgICBpZiAoZWxlbWVudC50eXBlID09PSBSZWFjdC5GcmFnbWVudCkge1xuICAgICAgLy8gVHJhbnNwYXJlbnRseSBzdXBwb3J0IFJlYWN0LkZyYWdtZW50IGFuZCBpdHMgY2hpbGRyZW4uXG4gICAgICByb3V0ZXMucHVzaC5hcHBseShyb3V0ZXMsIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbihlbGVtZW50LnByb3BzLmNoaWxkcmVuLCB0cmVlUGF0aCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAhKGVsZW1lbnQudHlwZSA9PT0gUm91dGUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgXCJbXCIgKyAodHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gXCJzdHJpbmdcIiA/IGVsZW1lbnQudHlwZSA6IGVsZW1lbnQudHlwZS5uYW1lKSArIFwiXSBpcyBub3QgYSA8Um91dGU+IGNvbXBvbmVudC4gQWxsIGNvbXBvbmVudCBjaGlsZHJlbiBvZiA8Um91dGVzPiBtdXN0IGJlIGEgPFJvdXRlPiBvciA8UmVhY3QuRnJhZ21lbnQ+XCIpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgISghZWxlbWVudC5wcm9wcy5pbmRleCB8fCAhZWxlbWVudC5wcm9wcy5jaGlsZHJlbikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCBcIkFuIGluZGV4IHJvdXRlIGNhbm5vdCBoYXZlIGNoaWxkIHJvdXRlcy5cIikgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBsZXQgcm91dGUgPSB7XG4gICAgICBpZDogZWxlbWVudC5wcm9wcy5pZCB8fCB0cmVlUGF0aC5qb2luKFwiLVwiKSxcbiAgICAgIGNhc2VTZW5zaXRpdmU6IGVsZW1lbnQucHJvcHMuY2FzZVNlbnNpdGl2ZSxcbiAgICAgIGVsZW1lbnQ6IGVsZW1lbnQucHJvcHMuZWxlbWVudCxcbiAgICAgIENvbXBvbmVudDogZWxlbWVudC5wcm9wcy5Db21wb25lbnQsXG4gICAgICBpbmRleDogZWxlbWVudC5wcm9wcy5pbmRleCxcbiAgICAgIHBhdGg6IGVsZW1lbnQucHJvcHMucGF0aCxcbiAgICAgIGxvYWRlcjogZWxlbWVudC5wcm9wcy5sb2FkZXIsXG4gICAgICBhY3Rpb246IGVsZW1lbnQucHJvcHMuYWN0aW9uLFxuICAgICAgZXJyb3JFbGVtZW50OiBlbGVtZW50LnByb3BzLmVycm9yRWxlbWVudCxcbiAgICAgIEVycm9yQm91bmRhcnk6IGVsZW1lbnQucHJvcHMuRXJyb3JCb3VuZGFyeSxcbiAgICAgIGhhc0Vycm9yQm91bmRhcnk6IGVsZW1lbnQucHJvcHMuRXJyb3JCb3VuZGFyeSAhPSBudWxsIHx8IGVsZW1lbnQucHJvcHMuZXJyb3JFbGVtZW50ICE9IG51bGwsXG4gICAgICBzaG91bGRSZXZhbGlkYXRlOiBlbGVtZW50LnByb3BzLnNob3VsZFJldmFsaWRhdGUsXG4gICAgICBoYW5kbGU6IGVsZW1lbnQucHJvcHMuaGFuZGxlLFxuICAgICAgbGF6eTogZWxlbWVudC5wcm9wcy5sYXp5XG4gICAgfTtcbiAgICBpZiAoZWxlbWVudC5wcm9wcy5jaGlsZHJlbikge1xuICAgICAgcm91dGUuY2hpbGRyZW4gPSBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4oZWxlbWVudC5wcm9wcy5jaGlsZHJlbiwgdHJlZVBhdGgpO1xuICAgIH1cbiAgICByb3V0ZXMucHVzaChyb3V0ZSk7XG4gIH0pO1xuICByZXR1cm4gcm91dGVzO1xufVxuXG4vKipcbiAqIFJlbmRlcnMgdGhlIHJlc3VsdCBvZiBgbWF0Y2hSb3V0ZXMoKWAgaW50byBhIFJlYWN0IGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlck1hdGNoZXMobWF0Y2hlcykge1xuICByZXR1cm4gX3JlbmRlck1hdGNoZXMobWF0Y2hlcyk7XG59XG5cbmZ1bmN0aW9uIG1hcFJvdXRlUHJvcGVydGllcyhyb3V0ZSkge1xuICBsZXQgdXBkYXRlcyA9IHtcbiAgICAvLyBOb3RlOiB0aGlzIGNoZWNrIGFsc28gb2NjdXJzIGluIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbiBzbyB1cGRhdGVcbiAgICAvLyB0aGVyZSBpZiB5b3UgY2hhbmdlIHRoaXMgLS0gcGxlYXNlIGFuZCB0aGFuayB5b3UhXG4gICAgaGFzRXJyb3JCb3VuZGFyeTogcm91dGUuRXJyb3JCb3VuZGFyeSAhPSBudWxsIHx8IHJvdXRlLmVycm9yRWxlbWVudCAhPSBudWxsXG4gIH07XG4gIGlmIChyb3V0ZS5Db21wb25lbnQpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBpZiAocm91dGUuZWxlbWVudCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfd2FybmluZyhmYWxzZSwgXCJZb3Ugc2hvdWxkIG5vdCBpbmNsdWRlIGJvdGggYENvbXBvbmVudGAgYW5kIGBlbGVtZW50YCBvbiB5b3VyIHJvdXRlIC0gXCIgKyBcImBDb21wb25lbnRgIHdpbGwgYmUgdXNlZC5cIikgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24odXBkYXRlcywge1xuICAgICAgZWxlbWVudDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQocm91dGUuQ29tcG9uZW50KSxcbiAgICAgIENvbXBvbmVudDogdW5kZWZpbmVkXG4gICAgfSk7XG4gIH1cbiAgaWYgKHJvdXRlLkh5ZHJhdGVGYWxsYmFjaykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGlmIChyb3V0ZS5oeWRyYXRlRmFsbGJhY2tFbGVtZW50KSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV93YXJuaW5nKGZhbHNlLCBcIllvdSBzaG91bGQgbm90IGluY2x1ZGUgYm90aCBgSHlkcmF0ZUZhbGxiYWNrYCBhbmQgYGh5ZHJhdGVGYWxsYmFja0VsZW1lbnRgIG9uIHlvdXIgcm91dGUgLSBcIiArIFwiYEh5ZHJhdGVGYWxsYmFja2Agd2lsbCBiZSB1c2VkLlwiKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbih1cGRhdGVzLCB7XG4gICAgICBoeWRyYXRlRmFsbGJhY2tFbGVtZW50OiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChyb3V0ZS5IeWRyYXRlRmFsbGJhY2spLFxuICAgICAgSHlkcmF0ZUZhbGxiYWNrOiB1bmRlZmluZWRcbiAgICB9KTtcbiAgfVxuICBpZiAocm91dGUuRXJyb3JCb3VuZGFyeSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGlmIChyb3V0ZS5lcnJvckVsZW1lbnQpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX3dhcm5pbmcoZmFsc2UsIFwiWW91IHNob3VsZCBub3QgaW5jbHVkZSBib3RoIGBFcnJvckJvdW5kYXJ5YCBhbmQgYGVycm9yRWxlbWVudGAgb24geW91ciByb3V0ZSAtIFwiICsgXCJgRXJyb3JCb3VuZGFyeWAgd2lsbCBiZSB1c2VkLlwiKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbih1cGRhdGVzLCB7XG4gICAgICBlcnJvckVsZW1lbnQ6IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KHJvdXRlLkVycm9yQm91bmRhcnkpLFxuICAgICAgRXJyb3JCb3VuZGFyeTogdW5kZWZpbmVkXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHVwZGF0ZXM7XG59XG5mdW5jdGlvbiBjcmVhdGVNZW1vcnlSb3V0ZXIocm91dGVzLCBvcHRzKSB7XG4gIHJldHVybiBjcmVhdGVSb3V0ZXIoe1xuICAgIGJhc2VuYW1lOiBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmJhc2VuYW1lLFxuICAgIGZ1dHVyZTogX2V4dGVuZHMoe30sIG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuZnV0dXJlLCB7XG4gICAgICB2N19wcmVwZW5kQmFzZW5hbWU6IHRydWVcbiAgICB9KSxcbiAgICBoaXN0b3J5OiBjcmVhdGVNZW1vcnlIaXN0b3J5KHtcbiAgICAgIGluaXRpYWxFbnRyaWVzOiBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmluaXRpYWxFbnRyaWVzLFxuICAgICAgaW5pdGlhbEluZGV4OiBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmluaXRpYWxJbmRleFxuICAgIH0pLFxuICAgIGh5ZHJhdGlvbkRhdGE6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuaHlkcmF0aW9uRGF0YSxcbiAgICByb3V0ZXMsXG4gICAgbWFwUm91dGVQcm9wZXJ0aWVzXG4gIH0pLmluaXRpYWxpemUoKTtcbn1cblxuZXhwb3J0IHsgQXdhaXQsIE1lbW9yeVJvdXRlciwgTmF2aWdhdGUsIE91dGxldCwgUm91dGUsIFJvdXRlciwgUm91dGVyUHJvdmlkZXIsIFJvdXRlcywgRGF0YVJvdXRlckNvbnRleHQgYXMgVU5TQUZFX0RhdGFSb3V0ZXJDb250ZXh0LCBEYXRhUm91dGVyU3RhdGVDb250ZXh0IGFzIFVOU0FGRV9EYXRhUm91dGVyU3RhdGVDb250ZXh0LCBMb2NhdGlvbkNvbnRleHQgYXMgVU5TQUZFX0xvY2F0aW9uQ29udGV4dCwgTmF2aWdhdGlvbkNvbnRleHQgYXMgVU5TQUZFX05hdmlnYXRpb25Db250ZXh0LCBSb3V0ZUNvbnRleHQgYXMgVU5TQUZFX1JvdXRlQ29udGV4dCwgbWFwUm91dGVQcm9wZXJ0aWVzIGFzIFVOU0FGRV9tYXBSb3V0ZVByb3BlcnRpZXMsIHVzZVJvdXRlSWQgYXMgVU5TQUZFX3VzZVJvdXRlSWQsIHVzZVJvdXRlc0ltcGwgYXMgVU5TQUZFX3VzZVJvdXRlc0ltcGwsIGNyZWF0ZU1lbW9yeVJvdXRlciwgY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuLCBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4gYXMgY3JlYXRlUm91dGVzRnJvbUVsZW1lbnRzLCByZW5kZXJNYXRjaGVzLCB1c2VBY3Rpb25EYXRhLCB1c2VBc3luY0Vycm9yLCB1c2VBc3luY1ZhbHVlLCB1c2VCbG9ja2VyLCB1c2VIcmVmLCB1c2VJblJvdXRlckNvbnRleHQsIHVzZUxvYWRlckRhdGEsIHVzZUxvY2F0aW9uLCB1c2VNYXRjaCwgdXNlTWF0Y2hlcywgdXNlTmF2aWdhdGUsIHVzZU5hdmlnYXRpb24sIHVzZU5hdmlnYXRpb25UeXBlLCB1c2VPdXRsZXQsIHVzZU91dGxldENvbnRleHQsIHVzZVBhcmFtcywgdXNlUmVzb2x2ZWRQYXRoLCB1c2VSZXZhbGlkYXRvciwgdXNlUm91dGVFcnJvciwgdXNlUm91dGVMb2FkZXJEYXRhLCB1c2VSb3V0ZXMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbIlJlYWN0IiwiVU5TQUZFX2ludmFyaWFudCIsImpvaW5QYXRocyIsIm1hdGNoUGF0aCIsIlVOU0FGRV9nZXRSZXNvbHZlVG9NYXRjaGVzIiwiVU5TQUZFX3dhcm5pbmciLCJyZXNvbHZlVG8iLCJwYXJzZVBhdGgiLCJtYXRjaFJvdXRlcyIsIkFjdGlvbiIsIlVOU0FGRV9jb252ZXJ0Um91dGVNYXRjaFRvVWlNYXRjaCIsInN0cmlwQmFzZW5hbWUiLCJJRExFX0JMT0NLRVIiLCJpc1JvdXRlRXJyb3JSZXNwb25zZSIsImNyZWF0ZU1lbW9yeUhpc3RvcnkiLCJBYm9ydGVkRGVmZXJyZWRFcnJvciIsImNyZWF0ZVJvdXRlciIsIk5hdmlnYXRpb25UeXBlIiwiY3JlYXRlUGF0aCIsImRlZmVyIiwiZ2VuZXJhdGVQYXRoIiwianNvbiIsInJlZGlyZWN0IiwicmVkaXJlY3REb2N1bWVudCIsInJlc29sdmVQYXRoIiwiX2V4dGVuZHMiLCJPYmplY3QiLCJhc3NpZ24iLCJiaW5kIiwidGFyZ2V0IiwiaSIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNvdXJjZSIsImtleSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImFwcGx5IiwiRGF0YVJvdXRlckNvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwicHJvY2VzcyIsImRpc3BsYXlOYW1lIiwiRGF0YVJvdXRlclN0YXRlQ29udGV4dCIsIkF3YWl0Q29udGV4dCIsIk5hdmlnYXRpb25Db250ZXh0IiwiTG9jYXRpb25Db250ZXh0IiwiUm91dGVDb250ZXh0Iiwib3V0bGV0IiwibWF0Y2hlcyIsImlzRGF0YVJvdXRlIiwiUm91dGVFcnJvckNvbnRleHQiLCJ1c2VIcmVmIiwidG8iLCJfdGVtcCIsInJlbGF0aXZlIiwidXNlSW5Sb3V0ZXJDb250ZXh0IiwiYmFzZW5hbWUiLCJuYXZpZ2F0b3IiLCJ1c2VDb250ZXh0IiwiaGFzaCIsInBhdGhuYW1lIiwic2VhcmNoIiwidXNlUmVzb2x2ZWRQYXRoIiwiam9pbmVkUGF0aG5hbWUiLCJjcmVhdGVIcmVmIiwidXNlTG9jYXRpb24iLCJsb2NhdGlvbiIsInVzZU5hdmlnYXRpb25UeXBlIiwibmF2aWdhdGlvblR5cGUiLCJ1c2VNYXRjaCIsInBhdHRlcm4iLCJ1c2VNZW1vIiwibmF2aWdhdGVFZmZlY3RXYXJuaW5nIiwidXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCIsImNiIiwiaXNTdGF0aWMiLCJzdGF0aWMiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VOYXZpZ2F0ZSIsInVzZU5hdmlnYXRlU3RhYmxlIiwidXNlTmF2aWdhdGVVbnN0YWJsZSIsImRhdGFSb3V0ZXJDb250ZXh0IiwiZnV0dXJlIiwibG9jYXRpb25QYXRobmFtZSIsInJvdXRlUGF0aG5hbWVzSnNvbiIsIkpTT04iLCJzdHJpbmdpZnkiLCJ2N19yZWxhdGl2ZVNwbGF0UGF0aCIsImFjdGl2ZVJlZiIsInVzZVJlZiIsImN1cnJlbnQiLCJuYXZpZ2F0ZSIsInVzZUNhbGxiYWNrIiwib3B0aW9ucyIsImdvIiwicGF0aCIsInBhcnNlIiwicmVwbGFjZSIsInB1c2giLCJzdGF0ZSIsIk91dGxldENvbnRleHQiLCJ1c2VPdXRsZXRDb250ZXh0IiwidXNlT3V0bGV0IiwiY29udGV4dCIsImNyZWF0ZUVsZW1lbnQiLCJQcm92aWRlciIsInZhbHVlIiwidXNlUGFyYW1zIiwicm91dGVNYXRjaCIsInBhcmFtcyIsIl90ZW1wMiIsInVzZVJvdXRlcyIsInJvdXRlcyIsImxvY2F0aW9uQXJnIiwidXNlUm91dGVzSW1wbCIsImRhdGFSb3V0ZXJTdGF0ZSIsInBhcmVudE1hdGNoZXMiLCJwYXJlbnRQYXJhbXMiLCJwYXJlbnRQYXRobmFtZSIsInBhcmVudFBhdGhuYW1lQmFzZSIsInBhdGhuYW1lQmFzZSIsInBhcmVudFJvdXRlIiwicm91dGUiLCJwYXJlbnRQYXRoIiwid2FybmluZ09uY2UiLCJlbmRzV2l0aCIsImxvY2F0aW9uRnJvbUNvbnRleHQiLCJfcGFyc2VkTG9jYXRpb25BcmckcGEiLCJwYXJzZWRMb2NhdGlvbkFyZyIsInN0YXJ0c1dpdGgiLCJyZW1haW5pbmdQYXRobmFtZSIsInNsaWNlIiwiZWxlbWVudCIsInVuZGVmaW5lZCIsIkNvbXBvbmVudCIsImxhenkiLCJyZW5kZXJlZE1hdGNoZXMiLCJfcmVuZGVyTWF0Y2hlcyIsIm1hcCIsIm1hdGNoIiwiZW5jb2RlTG9jYXRpb24iLCJQb3AiLCJEZWZhdWx0RXJyb3JDb21wb25lbnQiLCJlcnJvciIsInVzZVJvdXRlRXJyb3IiLCJtZXNzYWdlIiwic3RhdHVzIiwic3RhdHVzVGV4dCIsIkVycm9yIiwic3RhY2siLCJsaWdodGdyZXkiLCJwcmVTdHlsZXMiLCJwYWRkaW5nIiwiYmFja2dyb3VuZENvbG9yIiwiY29kZVN0eWxlcyIsImRldkluZm8iLCJjb25zb2xlIiwiRnJhZ21lbnQiLCJzdHlsZSIsImZvbnRTdHlsZSIsImRlZmF1bHRFcnJvckVsZW1lbnQiLCJSZW5kZXJFcnJvckJvdW5kYXJ5IiwiY29uc3RydWN0b3IiLCJwcm9wcyIsInJldmFsaWRhdGlvbiIsImdldERlcml2ZWRTdGF0ZUZyb21FcnJvciIsImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsImNvbXBvbmVudERpZENhdGNoIiwiZXJyb3JJbmZvIiwicmVuZGVyIiwicm91dGVDb250ZXh0IiwiY2hpbGRyZW4iLCJjb21wb25lbnQiLCJSZW5kZXJlZFJvdXRlIiwiX3JlZiIsInN0YXRpY0NvbnRleHQiLCJlcnJvckVsZW1lbnQiLCJFcnJvckJvdW5kYXJ5IiwiX2RlZXBlc3RSZW5kZXJlZEJvdW5kYXJ5SWQiLCJpZCIsIl9kYXRhUm91dGVyU3RhdGUyIiwiX2RhdGFSb3V0ZXJTdGF0ZSIsImVycm9ycyIsImVycm9ySW5kZXgiLCJmaW5kSW5kZXgiLCJtIiwia2V5cyIsImpvaW4iLCJNYXRoIiwibWluIiwicmVuZGVyRmFsbGJhY2siLCJmYWxsYmFja0luZGV4IiwidjdfcGFydGlhbEh5ZHJhdGlvbiIsIkh5ZHJhdGVGYWxsYmFjayIsImh5ZHJhdGVGYWxsYmFja0VsZW1lbnQiLCJsb2FkZXJEYXRhIiwibmVlZHNUb1J1bkxvYWRlciIsImxvYWRlciIsInJlZHVjZVJpZ2h0IiwiaW5kZXgiLCJzaG91bGRSZW5kZXJIeWRyYXRlRmFsbGJhY2siLCJjb25jYXQiLCJnZXRDaGlsZHJlbiIsIkRhdGFSb3V0ZXJIb29rIiwiRGF0YVJvdXRlclN0YXRlSG9vayIsImdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IiLCJob29rTmFtZSIsInVzZURhdGFSb3V0ZXJDb250ZXh0IiwiY3R4IiwidXNlRGF0YVJvdXRlclN0YXRlIiwidXNlUm91dGVDb250ZXh0IiwidXNlQ3VycmVudFJvdXRlSWQiLCJ0aGlzUm91dGUiLCJ1c2VSb3V0ZUlkIiwiVXNlUm91dGVJZCIsInVzZU5hdmlnYXRpb24iLCJVc2VOYXZpZ2F0aW9uIiwibmF2aWdhdGlvbiIsInVzZVJldmFsaWRhdG9yIiwiVXNlUmV2YWxpZGF0b3IiLCJyZXZhbGlkYXRlIiwicm91dGVyIiwidXNlTWF0Y2hlcyIsIlVzZU1hdGNoZXMiLCJ1c2VMb2FkZXJEYXRhIiwiVXNlTG9hZGVyRGF0YSIsInJvdXRlSWQiLCJ1c2VSb3V0ZUxvYWRlckRhdGEiLCJVc2VSb3V0ZUxvYWRlckRhdGEiLCJ1c2VBY3Rpb25EYXRhIiwiVXNlQWN0aW9uRGF0YSIsImFjdGlvbkRhdGEiLCJfc3RhdGUkZXJyb3JzIiwiVXNlUm91dGVFcnJvciIsInVzZUFzeW5jVmFsdWUiLCJfZGF0YSIsInVzZUFzeW5jRXJyb3IiLCJfZXJyb3IiLCJibG9ja2VySWQiLCJ1c2VCbG9ja2VyIiwic2hvdWxkQmxvY2siLCJVc2VCbG9ja2VyIiwiYmxvY2tlcktleSIsInNldEJsb2NrZXJLZXkiLCJ1c2VTdGF0ZSIsImJsb2NrZXJGdW5jdGlvbiIsImFyZyIsImN1cnJlbnRMb2NhdGlvbiIsIm5leHRMb2NhdGlvbiIsImhpc3RvcnlBY3Rpb24iLCJ1c2VFZmZlY3QiLCJTdHJpbmciLCJkZWxldGVCbG9ja2VyIiwiZ2V0QmxvY2tlciIsImJsb2NrZXJzIiwiaGFzIiwiZ2V0IiwiVXNlTmF2aWdhdGVTdGFibGUiLCJmcm9tUm91dGVJZCIsImFscmVhZHlXYXJuZWQiLCJjb25kIiwiU1RBUlRfVFJBTlNJVElPTiIsInN0YXJ0VHJhbnNpdGlvbkltcGwiLCJSb3V0ZXJQcm92aWRlciIsImZhbGxiYWNrRWxlbWVudCIsInNldFN0YXRlSW1wbCIsInY3X3N0YXJ0VHJhbnNpdGlvbiIsInNldFN0YXRlIiwibmV3U3RhdGUiLCJzdWJzY3JpYmUiLCJuIiwib3B0cyIsInByZXZlbnRTY3JvbGxSZXNldCIsIlJvdXRlciIsImluaXRpYWxpemVkIiwiRGF0YVJvdXRlcyIsIl9yZWYyIiwiTWVtb3J5Um91dGVyIiwiX3JlZjMiLCJpbml0aWFsRW50cmllcyIsImluaXRpYWxJbmRleCIsImhpc3RvcnlSZWYiLCJ2NUNvbXBhdCIsImhpc3RvcnkiLCJhY3Rpb24iLCJsaXN0ZW4iLCJOYXZpZ2F0ZSIsIl9yZWY0IiwianNvblBhdGgiLCJPdXRsZXQiLCJSb3V0ZSIsIl9wcm9wcyIsIl9yZWY1IiwiYmFzZW5hbWVQcm9wIiwibG9jYXRpb25Qcm9wIiwic3RhdGljUHJvcCIsIm5hdmlnYXRpb25Db250ZXh0IiwibG9jYXRpb25Db250ZXh0IiwidHJhaWxpbmdQYXRobmFtZSIsIlJvdXRlcyIsIl9yZWY2IiwiY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuIiwiQXdhaXQiLCJfcmVmNyIsInJlc29sdmUiLCJBd2FpdEVycm9yQm91bmRhcnkiLCJSZXNvbHZlQXdhaXQiLCJBd2FpdFJlbmRlclN0YXR1cyIsIm5ldmVyU2V0dGxlZFByb21pc2UiLCJQcm9taXNlIiwicHJvbWlzZSIsInBlbmRpbmciLCJzdWNjZXNzIiwiZGVmaW5lUHJvcGVydHkiLCJyZW5kZXJFcnJvciIsInJlamVjdCIsImNhdGNoIiwiX3RyYWNrZWQiLCJ0aGVuIiwiZGF0YSIsIl9yZWY4IiwidG9SZW5kZXIiLCJDaGlsZHJlbiIsImZvckVhY2giLCJpc1ZhbGlkRWxlbWVudCIsInRyZWVQYXRoIiwidHlwZSIsIm5hbWUiLCJjYXNlU2Vuc2l0aXZlIiwiaGFzRXJyb3JCb3VuZGFyeSIsInNob3VsZFJldmFsaWRhdGUiLCJoYW5kbGUiLCJyZW5kZXJNYXRjaGVzIiwibWFwUm91dGVQcm9wZXJ0aWVzIiwidXBkYXRlcyIsImNyZWF0ZU1lbW9yeVJvdXRlciIsInY3X3ByZXBlbmRCYXNlbmFtZSIsImh5ZHJhdGlvbkRhdGEiLCJpbml0aWFsaXplIiwiVU5TQUZFX0RhdGFSb3V0ZXJDb250ZXh0IiwiVU5TQUZFX0RhdGFSb3V0ZXJTdGF0ZUNvbnRleHQiLCJVTlNBRkVfTG9jYXRpb25Db250ZXh0IiwiVU5TQUZFX05hdmlnYXRpb25Db250ZXh0IiwiVU5TQUZFX1JvdXRlQ29udGV4dCIsIlVOU0FGRV9tYXBSb3V0ZVByb3BlcnRpZXMiLCJVTlNBRkVfdXNlUm91dGVJZCIsIlVOU0FGRV91c2VSb3V0ZXNJbXBsIiwiY3JlYXRlUm91dGVzRnJvbUVsZW1lbnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../../node_modules/react-router/dist/index.js\n");

/***/ })

};
;